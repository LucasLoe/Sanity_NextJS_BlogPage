"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/[pageCategory]",{

/***/ "./node_modules/@portabletext/react/dist/react-portable-text.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/react-portable-text.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PortableText\": function() { return /* binding */ PortableText; },\n/* harmony export */   \"defaultComponents\": function() { return /* binding */ defaultComponents; },\n/* harmony export */   \"mergeComponents\": function() { return /* binding */ mergeComponents; },\n/* harmony export */   \"toPlainText\": function() { return /* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.toPlainText; }\n/* harmony export */ });\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/toolkit */ \"./node_modules/@portabletext/toolkit/dist/portable-text-toolkit.esm.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\r\n  _excluded2 = [\"listItem\"],\r\n  _excluded3 = [\"_key\"];\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\r\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\r\n\r\n\r\n\r\n\r\nfunction mergeComponents(parent, overrides) {\r\n  const {\r\n      block,\r\n      list,\r\n      listItem,\r\n      marks,\r\n      types\r\n    } = overrides,\r\n    rest = _objectWithoutProperties(overrides, _excluded);\r\n  return _objectSpread(_objectSpread({}, parent), {}, {\r\n    block: mergeDeeply(parent, overrides, \"block\"),\r\n    list: mergeDeeply(parent, overrides, \"list\"),\r\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\r\n    marks: mergeDeeply(parent, overrides, \"marks\"),\r\n    types: mergeDeeply(parent, overrides, \"types\")\r\n  }, rest);\r\n}\r\nfunction mergeDeeply(parent, overrides, key) {\r\n  const override = overrides[key];\r\n  const parentVal = parent[key];\r\n  if (typeof override === \"function\") {\r\n    return override;\r\n  }\r\n  if (override && typeof parentVal === \"function\") {\r\n    return override;\r\n  }\r\n  if (override) {\r\n    return _objectSpread(_objectSpread({}, parentVal), override);\r\n  }\r\n  return parentVal;\r\n}\r\nconst link = _ref => {\r\n  let {\r\n    children,\r\n    value\r\n  } = _ref;\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", {\r\n    href: value == null ? void 0 : value.href,\r\n    children\r\n  });\r\n};\r\nconst underlineStyle = {\r\n  textDecoration: \"underline\"\r\n};\r\nconst defaultMarks = {\r\n  em: _ref2 => {\r\n    let {\r\n      children\r\n    } = _ref2;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"em\", {\r\n      children\r\n    });\r\n  },\r\n  strong: _ref3 => {\r\n    let {\r\n      children\r\n    } = _ref3;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"strong\", {\r\n      children\r\n    });\r\n  },\r\n  code: _ref4 => {\r\n    let {\r\n      children\r\n    } = _ref4;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"code\", {\r\n      children\r\n    });\r\n  },\r\n  underline: _ref5 => {\r\n    let {\r\n      children\r\n    } = _ref5;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\r\n      style: underlineStyle,\r\n      children\r\n    });\r\n  },\r\n  \"strike-through\": _ref6 => {\r\n    let {\r\n      children\r\n    } = _ref6;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"del\", {\r\n      children\r\n    });\r\n  },\r\n  link\r\n};\r\nconst defaultLists = {\r\n  number: _ref7 => {\r\n    let {\r\n      children\r\n    } = _ref7;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"ol\", {\r\n      children\r\n    });\r\n  },\r\n  bullet: _ref8 => {\r\n    let {\r\n      children\r\n    } = _ref8;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"ul\", {\r\n      children\r\n    });\r\n  }\r\n};\r\nconst DefaultListItem = _ref9 => {\r\n  let {\r\n    children\r\n  } = _ref9;\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"li\", {\r\n    children\r\n  });\r\n};\r\nconst getTemplate = (type, prop) => \"[@portabletext/react] Unknown \".concat(type, \", specify a component for it in the `components.\").concat(prop, \"` prop\");\r\nconst unknownTypeWarning = typeName => getTemplate(\"block type \\\"\".concat(typeName, \"\\\"\"), \"types\");\r\nconst unknownMarkWarning = markType => getTemplate(\"mark type \\\"\".concat(markType, \"\\\"\"), \"marks\");\r\nconst unknownBlockStyleWarning = blockStyle => getTemplate(\"block style \\\"\".concat(blockStyle, \"\\\"\"), \"block\");\r\nconst unknownListStyleWarning = listStyle => getTemplate(\"list style \\\"\".concat(listStyle, \"\\\"\"), \"list\");\r\nconst unknownListItemStyleWarning = listStyle => getTemplate(\"list item style \\\"\".concat(listStyle, \"\\\"\"), \"listItem\");\r\nfunction printWarning(message) {\r\n  console.warn(message);\r\n}\r\nconst hidden = {\r\n  display: \"none\"\r\n};\r\nconst DefaultUnknownType = _ref10 => {\r\n  let {\r\n    value,\r\n    isInline\r\n  } = _ref10;\r\n  const warning = unknownTypeWarning(value._type);\r\n  return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\r\n    style: hidden,\r\n    children: warning\r\n  }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\r\n    style: hidden,\r\n    children: warning\r\n  });\r\n};\r\nconst DefaultUnknownMark = _ref11 => {\r\n  let {\r\n    markType,\r\n    children\r\n  } = _ref11;\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\r\n    className: \"unknown__pt__mark__\".concat(markType),\r\n    children\r\n  });\r\n};\r\nconst DefaultUnknownBlockStyle = _ref12 => {\r\n  let {\r\n    children\r\n  } = _ref12;\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", {\r\n    children\r\n  });\r\n};\r\nconst DefaultUnknownList = _ref13 => {\r\n  let {\r\n    children\r\n  } = _ref13;\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"ul\", {\r\n    children\r\n  });\r\n};\r\nconst DefaultUnknownListItem = _ref14 => {\r\n  let {\r\n    children\r\n  } = _ref14;\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"li\", {\r\n    children\r\n  });\r\n};\r\nconst DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"br\", {});\r\nconst defaultBlockStyles = {\r\n  normal: _ref15 => {\r\n    let {\r\n      children\r\n    } = _ref15;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", {\r\n      children\r\n    });\r\n  },\r\n  blockquote: _ref16 => {\r\n    let {\r\n      children\r\n    } = _ref16;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"blockquote\", {\r\n      children\r\n    });\r\n  },\r\n  h1: _ref17 => {\r\n    let {\r\n      children\r\n    } = _ref17;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h1\", {\r\n      children\r\n    });\r\n  },\r\n  h2: _ref18 => {\r\n    let {\r\n      children\r\n    } = _ref18;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h2\", {\r\n      children\r\n    });\r\n  },\r\n  h3: _ref19 => {\r\n    let {\r\n      children\r\n    } = _ref19;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h3\", {\r\n      children\r\n    });\r\n  },\r\n  h4: _ref20 => {\r\n    let {\r\n      children\r\n    } = _ref20;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h4\", {\r\n      children\r\n    });\r\n  },\r\n  h5: _ref21 => {\r\n    let {\r\n      children\r\n    } = _ref21;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h5\", {\r\n      children\r\n    });\r\n  },\r\n  h6: _ref22 => {\r\n    let {\r\n      children\r\n    } = _ref22;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h6\", {\r\n      children\r\n    });\r\n  }\r\n};\r\nconst defaultComponents = {\r\n  types: {},\r\n  block: defaultBlockStyles,\r\n  marks: defaultMarks,\r\n  list: defaultLists,\r\n  listItem: DefaultListItem,\r\n  hardBreak: DefaultHardBreak,\r\n  unknownType: DefaultUnknownType,\r\n  unknownMark: DefaultUnknownMark,\r\n  unknownList: DefaultUnknownList,\r\n  unknownListItem: DefaultUnknownListItem,\r\n  unknownBlockStyle: DefaultUnknownBlockStyle\r\n};\r\nfunction PortableText(_ref23) {\r\n  let {\r\n    value: input,\r\n    components: componentOverrides,\r\n    listNestingMode,\r\n    onMissingComponent: missingComponentHandler = printWarning\r\n  } = _ref23;\r\n  const handleMissingComponent = missingComponentHandler || noop;\r\n  const blocks = Array.isArray(input) ? input : [input];\r\n  const nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.LIST_NEST_MODE_HTML);\r\n  const components = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => {\r\n    return componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents;\r\n  }, [componentOverrides]);\r\n  const renderNode = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]);\r\n  const rendered = nested.map((node, index) => renderNode({\r\n    node,\r\n    index,\r\n    isInline: false,\r\n    renderNode\r\n  }));\r\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\r\n    children: rendered\r\n  });\r\n}\r\nconst getNodeRenderer = (components, handleMissingComponent) => {\r\n  function renderNode(options) {\r\n    const {\r\n      node,\r\n      index,\r\n      isInline\r\n    } = options;\r\n    const key = node._key || \"node-\".concat(index);\r\n    if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitList)(node)) {\r\n      return renderList(node, index, key);\r\n    }\r\n    if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListItemBlock)(node)) {\r\n      return renderListItem(node, index, key);\r\n    }\r\n    if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitSpan)(node)) {\r\n      return renderSpan(node, index, key);\r\n    }\r\n    if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextBlock)(node)) {\r\n      return renderBlock(node, index, key, isInline);\r\n    }\r\n    if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitTextNode)(node)) {\r\n      return renderText(node, key);\r\n    }\r\n    return renderCustomBlock(node, index, key, isInline);\r\n  }\r\n  function renderListItem(node, index, key) {\r\n    const tree = serializeBlock({\r\n      node,\r\n      index,\r\n      isInline: false,\r\n      renderNode\r\n    });\r\n    const renderer = components.listItem;\r\n    const handler = typeof renderer === \"function\" ? renderer : renderer[node.listItem];\r\n    const Li = handler || components.unknownListItem;\r\n    if (Li === components.unknownListItem) {\r\n      const style = node.listItem || \"bullet\";\r\n      handleMissingComponent(unknownListItemStyleWarning(style), {\r\n        type: style,\r\n        nodeType: \"listItemStyle\"\r\n      });\r\n    }\r\n    let children = tree.children;\r\n    if (node.style && node.style !== \"normal\") {\r\n      const {\r\n          listItem\r\n        } = node,\r\n        blockNode = _objectWithoutProperties(node, _excluded2);\r\n      children = renderNode({\r\n        node: blockNode,\r\n        index,\r\n        isInline: false,\r\n        renderNode\r\n      });\r\n    }\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Li, {\r\n      value: node,\r\n      index,\r\n      isInline: false,\r\n      renderNode,\r\n      children\r\n    }, key);\r\n  }\r\n  function renderList(node, index, key) {\r\n    const children = node.children.map((child, childIndex) => renderNode({\r\n      node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\r\n        _key: \"li-\".concat(index, \"-\").concat(childIndex)\r\n      }),\r\n      index,\r\n      isInline: false,\r\n      renderNode\r\n    }));\r\n    const component = components.list;\r\n    const handler = typeof component === \"function\" ? component : component[node.listItem];\r\n    const List = handler || components.unknownList;\r\n    if (List === components.unknownList) {\r\n      const style = node.listItem || \"bullet\";\r\n      handleMissingComponent(unknownListStyleWarning(style), {\r\n        nodeType: \"listStyle\",\r\n        type: style\r\n      });\r\n    }\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(List, {\r\n      value: node,\r\n      index,\r\n      isInline: false,\r\n      renderNode,\r\n      children\r\n    }, key);\r\n  }\r\n  function renderSpan(node, _index, key) {\r\n    const {\r\n      markDef,\r\n      markType,\r\n      markKey\r\n    } = node;\r\n    const Span = components.marks[markType] || components.unknownMark;\r\n    const children = node.children.map((child, childIndex) => renderNode({\r\n      node: child,\r\n      index: childIndex,\r\n      isInline: true,\r\n      renderNode\r\n    }));\r\n    if (Span === components.unknownMark) {\r\n      handleMissingComponent(unknownMarkWarning(markType), {\r\n        nodeType: \"mark\",\r\n        type: markType\r\n      });\r\n    }\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Span, {\r\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.spanToPlainText)(node),\r\n      value: markDef,\r\n      markType,\r\n      markKey,\r\n      renderNode,\r\n      children\r\n    }, key);\r\n  }\r\n  function renderBlock(node, index, key, isInline) {\r\n    const _serializeBlock = serializeBlock({\r\n        node,\r\n        index,\r\n        isInline,\r\n        renderNode\r\n      }),\r\n      {\r\n        _key\r\n      } = _serializeBlock,\r\n      props = _objectWithoutProperties(_serializeBlock, _excluded3);\r\n    const style = props.node.style || \"normal\";\r\n    const handler = typeof components.block === \"function\" ? components.block : components.block[style];\r\n    const Block = handler || components.unknownBlockStyle;\r\n    if (Block === components.unknownBlockStyle) {\r\n      handleMissingComponent(unknownBlockStyleWarning(style), {\r\n        nodeType: \"blockStyle\",\r\n        type: style\r\n      });\r\n    }\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\r\n      value: props.node,\r\n      renderNode\r\n    }), key);\r\n  }\r\n  function renderText(node, key) {\r\n    if (node.text === \"\\n\") {\r\n      const HardBreak = components.hardBreak;\r\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(HardBreak, {}, key) : \"\\n\";\r\n    }\r\n    return node.text;\r\n  }\r\n  function renderCustomBlock(node, index, key, isInline) {\r\n    const Node = components.types[node._type];\r\n    const nodeOptions = {\r\n      value: node,\r\n      isInline,\r\n      index,\r\n      renderNode\r\n    };\r\n    if (Node) {\r\n      return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Node, _objectSpread({}, nodeOptions), key);\r\n    }\r\n    handleMissingComponent(unknownTypeWarning(node._type), {\r\n      nodeType: \"block\",\r\n      type: node._type\r\n    });\r\n    const UnknownType = components.unknownType;\r\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\r\n  }\r\n  return renderNode;\r\n};\r\nfunction serializeBlock(options) {\r\n  const {\r\n    node,\r\n    index,\r\n    isInline,\r\n    renderNode\r\n  } = options;\r\n  const tree = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildMarksTree)(node);\r\n  const children = tree.map((child, i) => renderNode({\r\n    node: child,\r\n    isInline: true,\r\n    index: i,\r\n    renderNode\r\n  }));\r\n  return {\r\n    _key: node._key || \"block-\".concat(index),\r\n    children,\r\n    index,\r\n    isInline,\r\n    node\r\n  };\r\n}\r\nfunction noop() {}\r\n\r\n//# sourceMappingURL=react-portable-text.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L3JlYWN0LXBvcnRhYmxlLXRleHQuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQztBQUN2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSztBQUMxZSw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUNwTSxzREFBc0QsK0JBQStCLDhEQUE4RCxZQUFZLG9DQUFvQyw2REFBNkQsWUFBWSw2QkFBNkIsT0FBTywyQkFBMkIsMENBQTBDLHdFQUF3RSwrQkFBK0I7QUFDNWQsMkRBQTJELCtCQUErQixpQkFBaUIsc0NBQXNDLFlBQVksWUFBWSx1QkFBdUIsT0FBTyxxQkFBcUIsMENBQTBDLDZCQUE2QjtBQUNwRDtBQUMzTDtBQUNGO0FBQ2xCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QixzREFBRztBQUMzQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsc0RBQUc7QUFDN0I7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsc0RBQUc7QUFDN0I7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsc0RBQUc7QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3QkFBd0Isc0RBQUc7QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1DQUFtQyxzREFBRztBQUN0QztBQUNBO0FBQ0EsR0FBRyxtQkFBbUIsc0RBQUc7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QixzREFBRztBQUMzQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QixzREFBRztBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3QkFBd0Isc0RBQUc7QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCLHNEQUFHO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOENBQThDLHNEQUFHLFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQVMsNEJBQTRCLHNFQUFtQjtBQUN6RSxxQkFBcUIsOENBQU87QUFDNUI7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLDhDQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLHNEQUFHLENBQUMsdURBQVE7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxRQUFRLGdGQUF5QjtBQUNqQztBQUNBO0FBQ0EsUUFBUSxrRkFBMkI7QUFDbkM7QUFDQTtBQUNBLFFBQVEsZ0ZBQXlCO0FBQ2pDO0FBQ0E7QUFDQSxRQUFRLDBFQUFtQjtBQUMzQjtBQUNBO0FBQ0EsUUFBUSxvRkFBNkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBCQUEwQixzREFBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMEJBQTBCLHNEQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBCQUEwQixzREFBRztBQUM3QixZQUFZLHNFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMEJBQTBCLHNEQUFHLHNDQUFzQyxZQUFZO0FBQy9FO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0RBQUcsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQUcsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLHNEQUFHLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSxxRUFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L3JlYWN0LXBvcnRhYmxlLXRleHQuZXNtLmpzPzA5MWEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgX2V4Y2x1ZGVkID0gW1wiYmxvY2tcIiwgXCJsaXN0XCIsIFwibGlzdEl0ZW1cIiwgXCJtYXJrc1wiLCBcInR5cGVzXCJdLFxyXG4gIF9leGNsdWRlZDIgPSBbXCJsaXN0SXRlbVwiXSxcclxuICBfZXhjbHVkZWQzID0gW1wiX2tleVwiXTtcclxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuaW1wb3J0IHsgbmVzdExpc3RzLCBMSVNUX05FU1RfTU9ERV9IVE1MLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBzcGFuVG9QbGFpblRleHQsIGJ1aWxkTWFya3NUcmVlIH0gZnJvbSAnQHBvcnRhYmxldGV4dC90b29sa2l0JztcclxuZXhwb3J0IHsgdG9QbGFpblRleHQgfSBmcm9tICdAcG9ydGFibGV0ZXh0L3Rvb2xraXQnO1xyXG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xyXG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xyXG5mdW5jdGlvbiBtZXJnZUNvbXBvbmVudHMocGFyZW50LCBvdmVycmlkZXMpIHtcclxuICBjb25zdCB7XHJcbiAgICAgIGJsb2NrLFxyXG4gICAgICBsaXN0LFxyXG4gICAgICBsaXN0SXRlbSxcclxuICAgICAgbWFya3MsXHJcbiAgICAgIHR5cGVzXHJcbiAgICB9ID0gb3ZlcnJpZGVzLFxyXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdmVycmlkZXMsIF9leGNsdWRlZCk7XHJcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50KSwge30sIHtcclxuICAgIGJsb2NrOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJibG9ja1wiKSxcclxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXHJcbiAgICBsaXN0SXRlbTogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdEl0ZW1cIiksXHJcbiAgICBtYXJrczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibWFya3NcIiksXHJcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIilcclxuICB9LCByZXN0KTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XHJcbiAgY29uc3Qgb3ZlcnJpZGUgPSBvdmVycmlkZXNba2V5XTtcclxuICBjb25zdCBwYXJlbnRWYWwgPSBwYXJlbnRba2V5XTtcclxuICBpZiAodHlwZW9mIG92ZXJyaWRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIHJldHVybiBvdmVycmlkZTtcclxuICB9XHJcbiAgaWYgKG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcmV0dXJuIG92ZXJyaWRlO1xyXG4gIH1cclxuICBpZiAob3ZlcnJpZGUpIHtcclxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFZhbCksIG92ZXJyaWRlKTtcclxuICB9XHJcbiAgcmV0dXJuIHBhcmVudFZhbDtcclxufVxyXG5jb25zdCBsaW5rID0gX3JlZiA9PiB7XHJcbiAgbGV0IHtcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgdmFsdWVcclxuICB9ID0gX3JlZjtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwiYVwiLCB7XHJcbiAgICBocmVmOiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuaHJlZixcclxuICAgIGNoaWxkcmVuXHJcbiAgfSk7XHJcbn07XHJcbmNvbnN0IHVuZGVybGluZVN0eWxlID0ge1xyXG4gIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRNYXJrcyA9IHtcclxuICBlbTogX3JlZjIgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmMjtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJlbVwiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIHN0cm9uZzogX3JlZjMgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmMztcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJzdHJvbmdcIiwge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBjb2RlOiBfcmVmNCA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IF9yZWY0O1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImNvZGVcIiwge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSk7XHJcbiAgfSxcclxuICB1bmRlcmxpbmU6IF9yZWY1ID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9ID0gX3JlZjU7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XHJcbiAgICAgIHN0eWxlOiB1bmRlcmxpbmVTdHlsZSxcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgXCJzdHJpa2UtdGhyb3VnaFwiOiBfcmVmNiA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IF9yZWY2O1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImRlbFwiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGxpbmtcclxufTtcclxuY29uc3QgZGVmYXVsdExpc3RzID0ge1xyXG4gIG51bWJlcjogX3JlZjcgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmNztcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJvbFwiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGJ1bGxldDogX3JlZjggPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmODtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcbmNvbnN0IERlZmF1bHRMaXN0SXRlbSA9IF9yZWY5ID0+IHtcclxuICBsZXQge1xyXG4gICAgY2hpbGRyZW5cclxuICB9ID0gX3JlZjk7XHJcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcclxuICAgIGNoaWxkcmVuXHJcbiAgfSk7XHJcbn07XHJcbmNvbnN0IGdldFRlbXBsYXRlID0gKHR5cGUsIHByb3ApID0+IFwiW0Bwb3J0YWJsZXRleHQvcmVhY3RdIFVua25vd24gXCIuY29uY2F0KHR5cGUsIFwiLCBzcGVjaWZ5IGEgY29tcG9uZW50IGZvciBpdCBpbiB0aGUgYGNvbXBvbmVudHMuXCIpLmNvbmNhdChwcm9wLCBcImAgcHJvcFwiKTtcclxuY29uc3QgdW5rbm93blR5cGVXYXJuaW5nID0gdHlwZU5hbWUgPT4gZ2V0VGVtcGxhdGUoXCJibG9jayB0eXBlIFxcXCJcIi5jb25jYXQodHlwZU5hbWUsIFwiXFxcIlwiKSwgXCJ0eXBlc1wiKTtcclxuY29uc3QgdW5rbm93bk1hcmtXYXJuaW5nID0gbWFya1R5cGUgPT4gZ2V0VGVtcGxhdGUoXCJtYXJrIHR5cGUgXFxcIlwiLmNvbmNhdChtYXJrVHlwZSwgXCJcXFwiXCIpLCBcIm1hcmtzXCIpO1xyXG5jb25zdCB1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcgPSBibG9ja1N0eWxlID0+IGdldFRlbXBsYXRlKFwiYmxvY2sgc3R5bGUgXFxcIlwiLmNvbmNhdChibG9ja1N0eWxlLCBcIlxcXCJcIiksIFwiYmxvY2tcIik7XHJcbmNvbnN0IHVua25vd25MaXN0U3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKFwibGlzdCBzdHlsZSBcXFwiXCIuY29uY2F0KGxpc3RTdHlsZSwgXCJcXFwiXCIpLCBcImxpc3RcIik7XHJcbmNvbnN0IHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShcImxpc3QgaXRlbSBzdHlsZSBcXFwiXCIuY29uY2F0KGxpc3RTdHlsZSwgXCJcXFwiXCIpLCBcImxpc3RJdGVtXCIpO1xyXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xyXG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxufVxyXG5jb25zdCBoaWRkZW4gPSB7XHJcbiAgZGlzcGxheTogXCJub25lXCJcclxufTtcclxuY29uc3QgRGVmYXVsdFVua25vd25UeXBlID0gX3JlZjEwID0+IHtcclxuICBsZXQge1xyXG4gICAgdmFsdWUsXHJcbiAgICBpc0lubGluZVxyXG4gIH0gPSBfcmVmMTA7XHJcbiAgY29uc3Qgd2FybmluZyA9IHVua25vd25UeXBlV2FybmluZyh2YWx1ZS5fdHlwZSk7XHJcbiAgcmV0dXJuIGlzSW5saW5lID8gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XHJcbiAgICBzdHlsZTogaGlkZGVuLFxyXG4gICAgY2hpbGRyZW46IHdhcm5pbmdcclxuICB9KSA6IC8qIEBfX1BVUkVfXyAqL2pzeChcImRpdlwiLCB7XHJcbiAgICBzdHlsZTogaGlkZGVuLFxyXG4gICAgY2hpbGRyZW46IHdhcm5pbmdcclxuICB9KTtcclxufTtcclxuY29uc3QgRGVmYXVsdFVua25vd25NYXJrID0gX3JlZjExID0+IHtcclxuICBsZXQge1xyXG4gICAgbWFya1R5cGUsXHJcbiAgICBjaGlsZHJlblxyXG4gIH0gPSBfcmVmMTE7XHJcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xyXG4gICAgY2xhc3NOYW1lOiBcInVua25vd25fX3B0X19tYXJrX19cIi5jb25jYXQobWFya1R5cGUpLFxyXG4gICAgY2hpbGRyZW5cclxuICB9KTtcclxufTtcclxuY29uc3QgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gX3JlZjEyID0+IHtcclxuICBsZXQge1xyXG4gICAgY2hpbGRyZW5cclxuICB9ID0gX3JlZjEyO1xyXG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJwXCIsIHtcclxuICAgIGNoaWxkcmVuXHJcbiAgfSk7XHJcbn07XHJcbmNvbnN0IERlZmF1bHRVbmtub3duTGlzdCA9IF9yZWYxMyA9PiB7XHJcbiAgbGV0IHtcclxuICAgIGNoaWxkcmVuXHJcbiAgfSA9IF9yZWYxMztcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xyXG4gICAgY2hpbGRyZW5cclxuICB9KTtcclxufTtcclxuY29uc3QgRGVmYXVsdFVua25vd25MaXN0SXRlbSA9IF9yZWYxNCA9PiB7XHJcbiAgbGV0IHtcclxuICAgIGNoaWxkcmVuXHJcbiAgfSA9IF9yZWYxNDtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwibGlcIiwge1xyXG4gICAgY2hpbGRyZW5cclxuICB9KTtcclxufTtcclxuY29uc3QgRGVmYXVsdEhhcmRCcmVhayA9ICgpID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJyXCIsIHt9KTtcclxuY29uc3QgZGVmYXVsdEJsb2NrU3R5bGVzID0ge1xyXG4gIG5vcm1hbDogX3JlZjE1ID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9ID0gX3JlZjE1O1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBibG9ja3F1b3RlOiBfcmVmMTYgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmMTY7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwiYmxvY2txdW90ZVwiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGgxOiBfcmVmMTcgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmMTc7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwiaDFcIiwge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBoMjogX3JlZjE4ID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9ID0gX3JlZjE4O1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImgyXCIsIHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgaDM6IF9yZWYxOSA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IF9yZWYxOTtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJoM1wiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGg0OiBfcmVmMjAgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0gPSBfcmVmMjA7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwiaDRcIiwge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBoNTogX3JlZjIxID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9ID0gX3JlZjIxO1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImg1XCIsIHtcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgaDY6IF9yZWYyMiA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IF9yZWYyMjtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJoNlwiLCB7XHJcbiAgICAgIGNoaWxkcmVuXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcbmNvbnN0IGRlZmF1bHRDb21wb25lbnRzID0ge1xyXG4gIHR5cGVzOiB7fSxcclxuICBibG9jazogZGVmYXVsdEJsb2NrU3R5bGVzLFxyXG4gIG1hcmtzOiBkZWZhdWx0TWFya3MsXHJcbiAgbGlzdDogZGVmYXVsdExpc3RzLFxyXG4gIGxpc3RJdGVtOiBEZWZhdWx0TGlzdEl0ZW0sXHJcbiAgaGFyZEJyZWFrOiBEZWZhdWx0SGFyZEJyZWFrLFxyXG4gIHVua25vd25UeXBlOiBEZWZhdWx0VW5rbm93blR5cGUsXHJcbiAgdW5rbm93bk1hcms6IERlZmF1bHRVbmtub3duTWFyayxcclxuICB1bmtub3duTGlzdDogRGVmYXVsdFVua25vd25MaXN0LFxyXG4gIHVua25vd25MaXN0SXRlbTogRGVmYXVsdFVua25vd25MaXN0SXRlbSxcclxuICB1bmtub3duQmxvY2tTdHlsZTogRGVmYXVsdFVua25vd25CbG9ja1N0eWxlXHJcbn07XHJcbmZ1bmN0aW9uIFBvcnRhYmxlVGV4dChfcmVmMjMpIHtcclxuICBsZXQge1xyXG4gICAgdmFsdWU6IGlucHV0LFxyXG4gICAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxyXG4gICAgbGlzdE5lc3RpbmdNb2RlLFxyXG4gICAgb25NaXNzaW5nQ29tcG9uZW50OiBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciA9IHByaW50V2FybmluZ1xyXG4gIH0gPSBfcmVmMjM7XHJcbiAgY29uc3QgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3A7XHJcbiAgY29uc3QgYmxvY2tzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XHJcbiAgY29uc3QgbmVzdGVkID0gbmVzdExpc3RzKGJsb2NrcywgbGlzdE5lc3RpbmdNb2RlIHx8IExJU1RfTkVTVF9NT0RFX0hUTUwpO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIHJldHVybiBjb21wb25lbnRPdmVycmlkZXMgPyBtZXJnZUNvbXBvbmVudHMoZGVmYXVsdENvbXBvbmVudHMsIGNvbXBvbmVudE92ZXJyaWRlcykgOiBkZWZhdWx0Q29tcG9uZW50cztcclxuICB9LCBbY29tcG9uZW50T3ZlcnJpZGVzXSk7XHJcbiAgY29uc3QgcmVuZGVyTm9kZSA9IHVzZU1lbW8oKCkgPT4gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpLCBbY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudF0pO1xyXG4gIGNvbnN0IHJlbmRlcmVkID0gbmVzdGVkLm1hcCgobm9kZSwgaW5kZXgpID0+IHJlbmRlck5vZGUoe1xyXG4gICAgbm9kZSxcclxuICAgIGluZGV4LFxyXG4gICAgaXNJbmxpbmU6IGZhbHNlLFxyXG4gICAgcmVuZGVyTm9kZVxyXG4gIH0pKTtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KEZyYWdtZW50LCB7XHJcbiAgICBjaGlsZHJlbjogcmVuZGVyZWRcclxuICB9KTtcclxufVxyXG5jb25zdCBnZXROb2RlUmVuZGVyZXIgPSAoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCkgPT4ge1xyXG4gIGZ1bmN0aW9uIHJlbmRlck5vZGUob3B0aW9ucykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBub2RlLFxyXG4gICAgICBpbmRleCxcclxuICAgICAgaXNJbmxpbmVcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qga2V5ID0gbm9kZS5fa2V5IHx8IFwibm9kZS1cIi5jb25jYXQoaW5kZXgpO1xyXG4gICAgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKG5vZGUpKSB7XHJcbiAgICAgIHJldHVybiByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KTtcclxuICAgIH1cclxuICAgIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKG5vZGUpKSB7XHJcbiAgICAgIHJldHVybiByZW5kZXJTcGFuKG5vZGUsIGluZGV4LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcclxuICAgIH1cclxuICAgIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSkge1xyXG4gICAgICByZXR1cm4gcmVuZGVyVGV4dChub2RlLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkge1xyXG4gICAgY29uc3QgdHJlZSA9IHNlcmlhbGl6ZUJsb2NrKHtcclxuICAgICAgbm9kZSxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIGlzSW5saW5lOiBmYWxzZSxcclxuICAgICAgcmVuZGVyTm9kZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZW5kZXJlciA9IGNvbXBvbmVudHMubGlzdEl0ZW07XHJcbiAgICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIHJlbmRlcmVyID09PSBcImZ1bmN0aW9uXCIgPyByZW5kZXJlciA6IHJlbmRlcmVyW25vZGUubGlzdEl0ZW1dO1xyXG4gICAgY29uc3QgTGkgPSBoYW5kbGVyIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtO1xyXG4gICAgaWYgKExpID09PSBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbSkge1xyXG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcclxuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcoc3R5bGUpLCB7XHJcbiAgICAgICAgdHlwZTogc3R5bGUsXHJcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdEl0ZW1TdHlsZVwiXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGV0IGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcclxuICAgIGlmIChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUgIT09IFwibm9ybWFsXCIpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgbGlzdEl0ZW1cclxuICAgICAgICB9ID0gbm9kZSxcclxuICAgICAgICBibG9ja05vZGUgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XHJcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyTm9kZSh7XHJcbiAgICAgICAgbm9kZTogYmxvY2tOb2RlLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgICAgIGlzSW5saW5lOiBmYWxzZSxcclxuICAgICAgICByZW5kZXJOb2RlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChMaSwge1xyXG4gICAgICB2YWx1ZTogbm9kZSxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIGlzSW5saW5lOiBmYWxzZSxcclxuICAgICAgcmVuZGVyTm9kZSxcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0sIGtleSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkge1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xyXG4gICAgICBub2RlOiBjaGlsZC5fa2V5ID8gY2hpbGQgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkKSwge30sIHtcclxuICAgICAgICBfa2V5OiBcImxpLVwiLmNvbmNhdChpbmRleCwgXCItXCIpLmNvbmNhdChjaGlsZEluZGV4KVxyXG4gICAgICB9KSxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIGlzSW5saW5lOiBmYWxzZSxcclxuICAgICAgcmVuZGVyTm9kZVxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50cy5saXN0O1xyXG4gICAgY29uc3QgaGFuZGxlciA9IHR5cGVvZiBjb21wb25lbnQgPT09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudCA6IGNvbXBvbmVudFtub2RlLmxpc3RJdGVtXTtcclxuICAgIGNvbnN0IExpc3QgPSBoYW5kbGVyIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3Q7XHJcbiAgICBpZiAoTGlzdCA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdCkge1xyXG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcclxuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdFN0eWxlV2FybmluZyhzdHlsZSksIHtcclxuICAgICAgICBub2RlVHlwZTogXCJsaXN0U3R5bGVcIixcclxuICAgICAgICB0eXBlOiBzdHlsZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGlzdCwge1xyXG4gICAgICB2YWx1ZTogbm9kZSxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIGlzSW5saW5lOiBmYWxzZSxcclxuICAgICAgcmVuZGVyTm9kZSxcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0sIGtleSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbmRlclNwYW4obm9kZSwgX2luZGV4LCBrZXkpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbWFya0RlZixcclxuICAgICAgbWFya1R5cGUsXHJcbiAgICAgIG1hcmtLZXlcclxuICAgIH0gPSBub2RlO1xyXG4gICAgY29uc3QgU3BhbiA9IGNvbXBvbmVudHMubWFya3NbbWFya1R5cGVdIHx8IGNvbXBvbmVudHMudW5rbm93bk1hcms7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XHJcbiAgICAgIG5vZGU6IGNoaWxkLFxyXG4gICAgICBpbmRleDogY2hpbGRJbmRleCxcclxuICAgICAgaXNJbmxpbmU6IHRydWUsXHJcbiAgICAgIHJlbmRlck5vZGVcclxuICAgIH0pKTtcclxuICAgIGlmIChTcGFuID09PSBjb21wb25lbnRzLnVua25vd25NYXJrKSB7XHJcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bk1hcmtXYXJuaW5nKG1hcmtUeXBlKSwge1xyXG4gICAgICAgIG5vZGVUeXBlOiBcIm1hcmtcIixcclxuICAgICAgICB0eXBlOiBtYXJrVHlwZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goU3Bhbiwge1xyXG4gICAgICB0ZXh0OiBzcGFuVG9QbGFpblRleHQobm9kZSksXHJcbiAgICAgIHZhbHVlOiBtYXJrRGVmLFxyXG4gICAgICBtYXJrVHlwZSxcclxuICAgICAgbWFya0tleSxcclxuICAgICAgcmVuZGVyTm9kZSxcclxuICAgICAgY2hpbGRyZW5cclxuICAgIH0sIGtleSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XHJcbiAgICBjb25zdCBfc2VyaWFsaXplQmxvY2sgPSBzZXJpYWxpemVCbG9jayh7XHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICBpbmRleCxcclxuICAgICAgICBpc0lubGluZSxcclxuICAgICAgICByZW5kZXJOb2RlXHJcbiAgICAgIH0pLFxyXG4gICAgICB7XHJcbiAgICAgICAgX2tleVxyXG4gICAgICB9ID0gX3NlcmlhbGl6ZUJsb2NrLFxyXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfc2VyaWFsaXplQmxvY2ssIF9leGNsdWRlZDMpO1xyXG4gICAgY29uc3Qgc3R5bGUgPSBwcm9wcy5ub2RlLnN0eWxlIHx8IFwibm9ybWFsXCI7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXTtcclxuICAgIGNvbnN0IEJsb2NrID0gaGFuZGxlciB8fCBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlO1xyXG4gICAgaWYgKEJsb2NrID09PSBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlKSB7XHJcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xyXG4gICAgICAgIG5vZGVUeXBlOiBcImJsb2NrU3R5bGVcIixcclxuICAgICAgICB0eXBlOiBzdHlsZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goQmxvY2ssIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xyXG4gICAgICB2YWx1ZTogcHJvcHMubm9kZSxcclxuICAgICAgcmVuZGVyTm9kZVxyXG4gICAgfSksIGtleSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbmRlclRleHQobm9kZSwga2V5KSB7XHJcbiAgICBpZiAobm9kZS50ZXh0ID09PSBcIlxcblwiKSB7XHJcbiAgICAgIGNvbnN0IEhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xyXG4gICAgICByZXR1cm4gSGFyZEJyZWFrID8gLyogQF9fUFVSRV9fICovanN4KEhhcmRCcmVhaywge30sIGtleSkgOiBcIlxcblwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGUudGV4dDtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcclxuICAgIGNvbnN0IE5vZGUgPSBjb21wb25lbnRzLnR5cGVzW25vZGUuX3R5cGVdO1xyXG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSB7XHJcbiAgICAgIHZhbHVlOiBub2RlLFxyXG4gICAgICBpc0lubGluZSxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIHJlbmRlck5vZGVcclxuICAgIH07XHJcbiAgICBpZiAoTm9kZSkge1xyXG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KE5vZGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KTtcclxuICAgIH1cclxuICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93blR5cGVXYXJuaW5nKG5vZGUuX3R5cGUpLCB7XHJcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrXCIsXHJcbiAgICAgIHR5cGU6IG5vZGUuX3R5cGVcclxuICAgIH0pO1xyXG4gICAgY29uc3QgVW5rbm93blR5cGUgPSBjb21wb25lbnRzLnVua25vd25UeXBlO1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChVbmtub3duVHlwZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVuZGVyTm9kZTtcclxufTtcclxuZnVuY3Rpb24gc2VyaWFsaXplQmxvY2sob3B0aW9ucykge1xyXG4gIGNvbnN0IHtcclxuICAgIG5vZGUsXHJcbiAgICBpbmRleCxcclxuICAgIGlzSW5saW5lLFxyXG4gICAgcmVuZGVyTm9kZVxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IHRyZWUgPSBidWlsZE1hcmtzVHJlZShub2RlKTtcclxuICBjb25zdCBjaGlsZHJlbiA9IHRyZWUubWFwKChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7XHJcbiAgICBub2RlOiBjaGlsZCxcclxuICAgIGlzSW5saW5lOiB0cnVlLFxyXG4gICAgaW5kZXg6IGksXHJcbiAgICByZW5kZXJOb2RlXHJcbiAgfSkpO1xyXG4gIHJldHVybiB7XHJcbiAgICBfa2V5OiBub2RlLl9rZXkgfHwgXCJibG9jay1cIi5jb25jYXQoaW5kZXgpLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBpbmRleCxcclxuICAgIGlzSW5saW5lLFxyXG4gICAgbm9kZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gbm9vcCgpIHt9XHJcbmV4cG9ydCB7IFBvcnRhYmxlVGV4dCwgZGVmYXVsdENvbXBvbmVudHMsIG1lcmdlQ29tcG9uZW50cyB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1wb3J0YWJsZS10ZXh0LmVzbS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@portabletext/react/dist/react-portable-text.esm.js\n"));

/***/ }),

/***/ "./node_modules/@portabletext/toolkit/dist/portable-text-toolkit.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/portable-text-toolkit.esm.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LIST_NEST_MODE_DIRECT\": function() { return /* binding */ LIST_NEST_MODE_DIRECT; },\n/* harmony export */   \"LIST_NEST_MODE_HTML\": function() { return /* binding */ LIST_NEST_MODE_HTML; },\n/* harmony export */   \"buildMarksTree\": function() { return /* binding */ buildMarksTree; },\n/* harmony export */   \"isPortableTextBlock\": function() { return /* binding */ isPortableTextBlock; },\n/* harmony export */   \"isPortableTextListItemBlock\": function() { return /* binding */ isPortableTextListItemBlock; },\n/* harmony export */   \"isPortableTextSpan\": function() { return /* binding */ isPortableTextSpan; },\n/* harmony export */   \"isPortableTextToolkitList\": function() { return /* binding */ isPortableTextToolkitList; },\n/* harmony export */   \"isPortableTextToolkitSpan\": function() { return /* binding */ isPortableTextToolkitSpan; },\n/* harmony export */   \"isPortableTextToolkitTextNode\": function() { return /* binding */ isPortableTextToolkitTextNode; },\n/* harmony export */   \"nestLists\": function() { return /* binding */ nestLists; },\n/* harmony export */   \"sortMarksByOccurences\": function() { return /* binding */ sortMarksByOccurences; },\n/* harmony export */   \"spanToPlainText\": function() { return /* binding */ spanToPlainText; },\n/* harmony export */   \"toPlainText\": function() { return /* binding */ toPlainText; }\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\nfunction isPortableTextSpan(node) {\r\n  return node._type === \"span\" && \"text\" in node && typeof node.text === \"string\" && (typeof node.marks === \"undefined\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark === \"string\"));\r\n}\r\nfunction isPortableTextBlock(node) {\r\n  return typeof node._type === \"string\" && node._type[0] !== \"@\" && (!(\"markDefs\" in node) || Array.isArray(node.markDefs) && node.markDefs.every(def => typeof def._key === \"string\")) && \"children\" in node && Array.isArray(node.children) && node.children.every(child => typeof child === \"object\" && \"_type\" in child);\r\n}\r\nfunction isPortableTextListItemBlock(block) {\r\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem === \"string\" && (typeof block.level === \"undefined\" || typeof block.level === \"number\");\r\n}\r\nfunction isPortableTextToolkitList(block) {\r\n  return block._type === \"@list\";\r\n}\r\nfunction isPortableTextToolkitSpan(span) {\r\n  return span._type === \"@span\";\r\n}\r\nfunction isPortableTextToolkitTextNode(node) {\r\n  return node._type === \"@text\";\r\n}\r\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\r\nfunction sortMarksByOccurences(span, index, blockChildren) {\r\n  if (!isPortableTextSpan(span) || !span.marks) {\r\n    return [];\r\n  }\r\n  if (!span.marks.length) {\r\n    return [];\r\n  }\r\n  const marks = span.marks.slice();\r\n  const occurences = {};\r\n  marks.forEach(mark => {\r\n    occurences[mark] = 1;\r\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\r\n      const sibling = blockChildren[siblingIndex];\r\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\r\n        occurences[mark]++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  });\r\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\r\n}\r\nfunction sortMarks(occurences, markA, markB) {\r\n  const aOccurences = occurences[markA];\r\n  const bOccurences = occurences[markB];\r\n  if (aOccurences !== bOccurences) {\r\n    return bOccurences - aOccurences;\r\n  }\r\n  const aKnownPos = knownDecorators.indexOf(markA);\r\n  const bKnownPos = knownDecorators.indexOf(markB);\r\n  if (aKnownPos !== bKnownPos) {\r\n    return aKnownPos - bKnownPos;\r\n  }\r\n  return markA.localeCompare(markB);\r\n}\r\nfunction buildMarksTree(block) {\r\n  var _a;\r\n  const {\r\n    children,\r\n    markDefs = []\r\n  } = block;\r\n  if (!children || !children.length) {\r\n    return [];\r\n  }\r\n  const sortedMarks = children.map(sortMarksByOccurences);\r\n  const rootNode = {\r\n    _type: \"@span\",\r\n    children: [],\r\n    markType: \"<unknown>\"\r\n  };\r\n  let nodeStack = [rootNode];\r\n  for (let i = 0; i < children.length; i++) {\r\n    const span = children[i];\r\n    if (!span) {\r\n      continue;\r\n    }\r\n    const marksNeeded = sortedMarks[i] || [];\r\n    let pos = 1;\r\n    if (nodeStack.length > 1) {\r\n      for (pos; pos < nodeStack.length; pos++) {\r\n        const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\";\r\n        const index = marksNeeded.indexOf(mark);\r\n        if (index === -1) {\r\n          break;\r\n        }\r\n        marksNeeded.splice(index, 1);\r\n      }\r\n    }\r\n    nodeStack = nodeStack.slice(0, pos);\r\n    let currentNode = nodeStack[nodeStack.length - 1];\r\n    if (!currentNode) {\r\n      continue;\r\n    }\r\n    for (const markKey of marksNeeded) {\r\n      const markDef = markDefs.find(def => def._key === markKey);\r\n      const markType = markDef ? markDef._type : markKey;\r\n      const node = {\r\n        _type: \"@span\",\r\n        _key: span._key,\r\n        children: [],\r\n        markDef,\r\n        markType,\r\n        markKey\r\n      };\r\n      currentNode.children.push(node);\r\n      nodeStack.push(node);\r\n      currentNode = node;\r\n    }\r\n    if (isPortableTextSpan(span)) {\r\n      const lines = span.text.split(\"\\n\");\r\n      for (let line = lines.length; line-- > 1;) {\r\n        lines.splice(line, 0, \"\\n\");\r\n      }\r\n      currentNode.children = currentNode.children.concat(lines.map(text => ({\r\n        _type: \"@text\",\r\n        text\r\n      })));\r\n    } else {\r\n      currentNode.children = currentNode.children.concat(span);\r\n    }\r\n  }\r\n  return rootNode.children;\r\n}\r\nfunction nestLists(blocks, mode) {\r\n  const tree = [];\r\n  let currentList;\r\n  for (let i = 0; i < blocks.length; i++) {\r\n    const block = blocks[i];\r\n    if (!block) {\r\n      continue;\r\n    }\r\n    if (!isPortableTextListItemBlock(block)) {\r\n      tree.push(block);\r\n      currentList = void 0;\r\n      continue;\r\n    }\r\n    if (!currentList) {\r\n      currentList = listFromBlock(block, i, mode);\r\n      tree.push(currentList);\r\n      continue;\r\n    }\r\n    if (blockMatchesList(block, currentList)) {\r\n      currentList.children.push(block);\r\n      continue;\r\n    }\r\n    if ((block.level || 1) > currentList.level) {\r\n      const newList = listFromBlock(block, i, mode);\r\n      if (mode === \"html\") {\r\n        const lastListItem = currentList.children[currentList.children.length - 1];\r\n        const newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\r\n          children: [...lastListItem.children, newList]\r\n        });\r\n        currentList.children[currentList.children.length - 1] = newLastChild;\r\n      } else {\r\n        currentList.children.push(newList);\r\n      }\r\n      currentList = newList;\r\n      continue;\r\n    }\r\n    if ((block.level || 1) < currentList.level) {\r\n      const matchingBranch = tree[tree.length - 1];\r\n      const match = matchingBranch && findListMatching(matchingBranch, block);\r\n      if (match) {\r\n        currentList = match;\r\n        currentList.children.push(block);\r\n        continue;\r\n      }\r\n      currentList = listFromBlock(block, i, mode);\r\n      tree.push(currentList);\r\n      continue;\r\n    }\r\n    if (block.listItem !== currentList.listItem) {\r\n      const matchingBranch = tree[tree.length - 1];\r\n      const match = matchingBranch && findListMatching(matchingBranch, {\r\n        level: block.level || 1\r\n      });\r\n      if (match && match.listItem === block.listItem) {\r\n        currentList = match;\r\n        currentList.children.push(block);\r\n        continue;\r\n      } else {\r\n        currentList = listFromBlock(block, i, mode);\r\n        tree.push(currentList);\r\n        continue;\r\n      }\r\n    }\r\n    console.warn(\"Unknown state encountered for block\", block);\r\n    tree.push(block);\r\n  }\r\n  return tree;\r\n}\r\nfunction blockMatchesList(block, list) {\r\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\r\n}\r\nfunction listFromBlock(block, index, mode) {\r\n  return {\r\n    _type: \"@list\",\r\n    _key: \"\".concat(block._key || \"\".concat(index), \"-parent\"),\r\n    mode,\r\n    level: block.level || 1,\r\n    listItem: block.listItem,\r\n    children: [block]\r\n  };\r\n}\r\nfunction findListMatching(rootNode, matching) {\r\n  const level = matching.level || 1;\r\n  const style = matching.listItem || \"normal\";\r\n  const filterOnType = typeof matching.listItem === \"string\";\r\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) {\r\n    return rootNode;\r\n  }\r\n  if (!(\"children\" in rootNode)) {\r\n    return void 0;\r\n  }\r\n  const node = rootNode.children[rootNode.children.length - 1];\r\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\r\n}\r\nconst leadingSpace = /^\\s/;\r\nconst trailingSpace = /^\\s/;\r\nfunction toPlainText(block) {\r\n  const blocks = Array.isArray(block) ? block : [block];\r\n  let text = \"\";\r\n  blocks.forEach((current, index) => {\r\n    if (!isPortableTextBlock(current)) {\r\n      return;\r\n    }\r\n    let pad = false;\r\n    current.children.forEach(span => {\r\n      if (isPortableTextSpan(span)) {\r\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\";\r\n        text += span.text;\r\n        pad = false;\r\n      } else {\r\n        pad = true;\r\n      }\r\n    });\r\n    if (index !== blocks.length - 1) {\r\n      text += \"\\n\\n\";\r\n    }\r\n  });\r\n  return text;\r\n}\r\nfunction spanToPlainText(span) {\r\n  let text = \"\";\r\n  span.children.forEach(current => {\r\n    if (isPortableTextToolkitTextNode(current)) {\r\n      text += current.text;\r\n    } else if (isPortableTextToolkitSpan(current)) {\r\n      text += spanToPlainText(current);\r\n    }\r\n  });\r\n  return text;\r\n}\r\nconst LIST_NEST_MODE_HTML = \"html\";\r\nconst LIST_NEST_MODE_DIRECT = \"direct\";\r\n\r\n//# sourceMappingURL=portable-text-toolkit.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvcG9ydGFibGUtdGV4dC10b29sa2l0LmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDO0FBQ3ZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELDZEQUE2RCw0Q0FBNEMsb0tBQW9LLG1GQUFtRixLQUFLO0FBQzFlLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9CO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUJBQW1CO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNpUztBQUNqUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvcG9ydGFibGUtdGV4dC10b29sa2l0LmVzbS5qcz85YWNkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiICYmIFwidGV4dFwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUudGV4dCA9PT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPT09IFwidW5kZWZpbmVkXCIgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmV2ZXJ5KG1hcmsgPT4gdHlwZW9mIG1hcmsgPT09IFwic3RyaW5nXCIpKTtcclxufVxyXG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpIHtcclxuICByZXR1cm4gdHlwZW9mIG5vZGUuX3R5cGUgPT09IFwic3RyaW5nXCIgJiYgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgKCEoXCJtYXJrRGVmc1wiIGluIG5vZGUpIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiYgbm9kZS5tYXJrRGVmcy5ldmVyeShkZWYgPT4gdHlwZW9mIGRlZi5fa2V5ID09PSBcInN0cmluZ1wiKSkgJiYgXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSAmJiBub2RlLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykge1xyXG4gIHJldHVybiBpc1BvcnRhYmxlVGV4dEJsb2NrKGJsb2NrKSAmJiBcImxpc3RJdGVtXCIgaW4gYmxvY2sgJiYgdHlwZW9mIGJsb2NrLmxpc3RJdGVtID09PSBcInN0cmluZ1wiICYmICh0eXBlb2YgYmxvY2subGV2ZWwgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGJsb2NrLmxldmVsID09PSBcIm51bWJlclwiKTtcclxufVxyXG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KGJsb2NrKSB7XHJcbiAgcmV0dXJuIGJsb2NrLl90eXBlID09PSBcIkBsaXN0XCI7XHJcbn1cclxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihzcGFuKSB7XHJcbiAgcmV0dXJuIHNwYW4uX3R5cGUgPT09IFwiQHNwYW5cIjtcclxufVxyXG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiQHRleHRcIjtcclxufVxyXG5jb25zdCBrbm93bkRlY29yYXRvcnMgPSBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcImNvZGVcIiwgXCJ1bmRlcmxpbmVcIiwgXCJzdHJpa2UtdGhyb3VnaFwiXTtcclxuZnVuY3Rpb24gc29ydE1hcmtzQnlPY2N1cmVuY2VzKHNwYW4sIGluZGV4LCBibG9ja0NoaWxkcmVuKSB7XHJcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgfHwgIXNwYW4ubWFya3MpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgaWYgKCFzcGFuLm1hcmtzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBjb25zdCBtYXJrcyA9IHNwYW4ubWFya3Muc2xpY2UoKTtcclxuICBjb25zdCBvY2N1cmVuY2VzID0ge307XHJcbiAgbWFya3MuZm9yRWFjaChtYXJrID0+IHtcclxuICAgIG9jY3VyZW5jZXNbbWFya10gPSAxO1xyXG4gICAgZm9yIChsZXQgc2libGluZ0luZGV4ID0gaW5kZXggKyAxOyBzaWJsaW5nSW5kZXggPCBibG9ja0NoaWxkcmVuLmxlbmd0aDsgc2libGluZ0luZGV4KyspIHtcclxuICAgICAgY29uc3Qgc2libGluZyA9IGJsb2NrQ2hpbGRyZW5bc2libGluZ0luZGV4XTtcclxuICAgICAgaWYgKHNpYmxpbmcgJiYgaXNQb3J0YWJsZVRleHRTcGFuKHNpYmxpbmcpICYmIEFycmF5LmlzQXJyYXkoc2libGluZy5tYXJrcykgJiYgc2libGluZy5tYXJrcy5pbmRleE9mKG1hcmspICE9PSAtMSkge1xyXG4gICAgICAgIG9jY3VyZW5jZXNbbWFya10rKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBtYXJrcy5zb3J0KChtYXJrQSwgbWFya0IpID0+IHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpKTtcclxufVxyXG5mdW5jdGlvbiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSB7XHJcbiAgY29uc3QgYU9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtBXTtcclxuICBjb25zdCBiT2NjdXJlbmNlcyA9IG9jY3VyZW5jZXNbbWFya0JdO1xyXG4gIGlmIChhT2NjdXJlbmNlcyAhPT0gYk9jY3VyZW5jZXMpIHtcclxuICAgIHJldHVybiBiT2NjdXJlbmNlcyAtIGFPY2N1cmVuY2VzO1xyXG4gIH1cclxuICBjb25zdCBhS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQSk7XHJcbiAgY29uc3QgYktub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0IpO1xyXG4gIGlmIChhS25vd25Qb3MgIT09IGJLbm93blBvcykge1xyXG4gICAgcmV0dXJuIGFLbm93blBvcyAtIGJLbm93blBvcztcclxuICB9XHJcbiAgcmV0dXJuIG1hcmtBLmxvY2FsZUNvbXBhcmUobWFya0IpO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkTWFya3NUcmVlKGJsb2NrKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IHtcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgbWFya0RlZnMgPSBbXVxyXG4gIH0gPSBibG9jaztcclxuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgY29uc3Qgc29ydGVkTWFya3MgPSBjaGlsZHJlbi5tYXAoc29ydE1hcmtzQnlPY2N1cmVuY2VzKTtcclxuICBjb25zdCByb290Tm9kZSA9IHtcclxuICAgIF90eXBlOiBcIkBzcGFuXCIsXHJcbiAgICBjaGlsZHJlbjogW10sXHJcbiAgICBtYXJrVHlwZTogXCI8dW5rbm93bj5cIlxyXG4gIH07XHJcbiAgbGV0IG5vZGVTdGFjayA9IFtyb290Tm9kZV07XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgc3BhbiA9IGNoaWxkcmVuW2ldO1xyXG4gICAgaWYgKCFzcGFuKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFya3NOZWVkZWQgPSBzb3J0ZWRNYXJrc1tpXSB8fCBbXTtcclxuICAgIGxldCBwb3MgPSAxO1xyXG4gICAgaWYgKG5vZGVTdGFjay5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGZvciAocG9zOyBwb3MgPCBub2RlU3RhY2subGVuZ3RoOyBwb3MrKykge1xyXG4gICAgICAgIGNvbnN0IG1hcmsgPSAoKF9hID0gbm9kZVN0YWNrW3Bvc10pID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrS2V5KSB8fCBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWFya3NOZWVkZWQuaW5kZXhPZihtYXJrKTtcclxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya3NOZWVkZWQuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbm9kZVN0YWNrID0gbm9kZVN0YWNrLnNsaWNlKDAsIHBvcyk7XHJcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKCFjdXJyZW50Tm9kZSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbWFya0tleSBvZiBtYXJrc05lZWRlZCkge1xyXG4gICAgICBjb25zdCBtYXJrRGVmID0gbWFya0RlZnMuZmluZChkZWYgPT4gZGVmLl9rZXkgPT09IG1hcmtLZXkpO1xyXG4gICAgICBjb25zdCBtYXJrVHlwZSA9IG1hcmtEZWYgPyBtYXJrRGVmLl90eXBlIDogbWFya0tleTtcclxuICAgICAgY29uc3Qgbm9kZSA9IHtcclxuICAgICAgICBfdHlwZTogXCJAc3BhblwiLFxyXG4gICAgICAgIF9rZXk6IHNwYW4uX2tleSxcclxuICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgbWFya0RlZixcclxuICAgICAgICBtYXJrVHlwZSxcclxuICAgICAgICBtYXJrS2V5XHJcbiAgICAgIH07XHJcbiAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSk7XHJcbiAgICAgIG5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pKSB7XHJcbiAgICAgIGNvbnN0IGxpbmVzID0gc3Bhbi50ZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICBmb3IgKGxldCBsaW5lID0gbGluZXMubGVuZ3RoOyBsaW5lLS0gPiAxOykge1xyXG4gICAgICAgIGxpbmVzLnNwbGljZShsaW5lLCAwLCBcIlxcblwiKTtcclxuICAgICAgfVxyXG4gICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChsaW5lcy5tYXAodGV4dCA9PiAoe1xyXG4gICAgICAgIF90eXBlOiBcIkB0ZXh0XCIsXHJcbiAgICAgICAgdGV4dFxyXG4gICAgICB9KSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBuZXN0TGlzdHMoYmxvY2tzLCBtb2RlKSB7XHJcbiAgY29uc3QgdHJlZSA9IFtdO1xyXG4gIGxldCBjdXJyZW50TGlzdDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XHJcbiAgICBpZiAoIWJsb2NrKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spKSB7XHJcbiAgICAgIHRyZWUucHVzaChibG9jayk7XHJcbiAgICAgIGN1cnJlbnRMaXN0ID0gdm9pZCAwO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmICghY3VycmVudExpc3QpIHtcclxuICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcclxuICAgICAgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2tNYXRjaGVzTGlzdChibG9jaywgY3VycmVudExpc3QpKSB7XHJcbiAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPiBjdXJyZW50TGlzdC5sZXZlbCkge1xyXG4gICAgICBjb25zdCBuZXdMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSk7XHJcbiAgICAgIGlmIChtb2RlID09PSBcImh0bWxcIikge1xyXG4gICAgICAgIGNvbnN0IGxhc3RMaXN0SXRlbSA9IGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGNvbnN0IG5ld0xhc3RDaGlsZCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGFzdExpc3RJdGVtKSwge30sIHtcclxuICAgICAgICAgIGNoaWxkcmVuOiBbLi4ubGFzdExpc3RJdGVtLmNoaWxkcmVuLCBuZXdMaXN0XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbmV3TGFzdENoaWxkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2gobmV3TGlzdCk7XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudExpc3QgPSBuZXdMaXN0O1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPCBjdXJyZW50TGlzdC5sZXZlbCkge1xyXG4gICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCBibG9jayk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2g7XHJcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcclxuICAgICAgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAoYmxvY2subGlzdEl0ZW0gIT09IGN1cnJlbnRMaXN0Lmxpc3RJdGVtKSB7XHJcbiAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xyXG4gICAgICBjb25zdCBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIHtcclxuICAgICAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxpc3RJdGVtID09PSBibG9jay5saXN0SXRlbSkge1xyXG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2g7XHJcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcclxuICAgICAgICB0cmVlLnB1c2goY3VycmVudExpc3QpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHN0YXRlIGVuY291bnRlcmVkIGZvciBibG9ja1wiLCBibG9jayk7XHJcbiAgICB0cmVlLnB1c2goYmxvY2spO1xyXG4gIH1cclxuICByZXR1cm4gdHJlZTtcclxufVxyXG5mdW5jdGlvbiBibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBsaXN0KSB7XHJcbiAgcmV0dXJuIChibG9jay5sZXZlbCB8fCAxKSA9PT0gbGlzdC5sZXZlbCAmJiBibG9jay5saXN0SXRlbSA9PT0gbGlzdC5saXN0SXRlbTtcclxufVxyXG5mdW5jdGlvbiBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpbmRleCwgbW9kZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBfdHlwZTogXCJAbGlzdFwiLFxyXG4gICAgX2tleTogXCJcIi5jb25jYXQoYmxvY2suX2tleSB8fCBcIlwiLmNvbmNhdChpbmRleCksIFwiLXBhcmVudFwiKSxcclxuICAgIG1vZGUsXHJcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcclxuICAgIGxpc3RJdGVtOiBibG9jay5saXN0SXRlbSxcclxuICAgIGNoaWxkcmVuOiBbYmxvY2tdXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTGlzdE1hdGNoaW5nKHJvb3ROb2RlLCBtYXRjaGluZykge1xyXG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMTtcclxuICBjb25zdCBzdHlsZSA9IG1hdGNoaW5nLmxpc3RJdGVtIHx8IFwibm9ybWFsXCI7XHJcbiAgY29uc3QgZmlsdGVyT25UeXBlID0gdHlwZW9mIG1hdGNoaW5nLmxpc3RJdGVtID09PSBcInN0cmluZ1wiO1xyXG4gIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KHJvb3ROb2RlKSAmJiAocm9vdE5vZGUubGV2ZWwgfHwgMSkgPT09IGxldmVsICYmIGZpbHRlck9uVHlwZSAmJiAocm9vdE5vZGUubGlzdEl0ZW0gfHwgXCJub3JtYWxcIikgPT09IHN0eWxlKSB7XHJcbiAgICByZXR1cm4gcm9vdE5vZGU7XHJcbiAgfVxyXG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpIHtcclxuICAgIHJldHVybiB2b2lkIDA7XHJcbiAgfVxyXG4gIGNvbnN0IG5vZGUgPSByb290Tm9kZS5jaGlsZHJlbltyb290Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcclxuICByZXR1cm4gbm9kZSAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpID8gZmluZExpc3RNYXRjaGluZyhub2RlLCBtYXRjaGluZykgOiB2b2lkIDA7XHJcbn1cclxuY29uc3QgbGVhZGluZ1NwYWNlID0gL15cXHMvO1xyXG5jb25zdCB0cmFpbGluZ1NwYWNlID0gL15cXHMvO1xyXG5mdW5jdGlvbiB0b1BsYWluVGV4dChibG9jaykge1xyXG4gIGNvbnN0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoYmxvY2spID8gYmxvY2sgOiBbYmxvY2tdO1xyXG4gIGxldCB0ZXh0ID0gXCJcIjtcclxuICBibG9ja3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcclxuICAgIGlmICghaXNQb3J0YWJsZVRleHRCbG9jayhjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcGFkID0gZmFsc2U7XHJcbiAgICBjdXJyZW50LmNoaWxkcmVuLmZvckVhY2goc3BhbiA9PiB7XHJcbiAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcclxuICAgICAgICB0ZXh0ICs9IHBhZCAmJiB0ZXh0ICYmICF0cmFpbGluZ1NwYWNlLnRlc3QodGV4dCkgJiYgIWxlYWRpbmdTcGFjZS50ZXN0KHNwYW4udGV4dCkgPyBcIiBcIiA6IFwiXCI7XHJcbiAgICAgICAgdGV4dCArPSBzcGFuLnRleHQ7XHJcbiAgICAgICAgcGFkID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoaW5kZXggIT09IGJsb2Nrcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIHRleHQgKz0gXCJcXG5cXG5cIjtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gdGV4dDtcclxufVxyXG5mdW5jdGlvbiBzcGFuVG9QbGFpblRleHQoc3Bhbikge1xyXG4gIGxldCB0ZXh0ID0gXCJcIjtcclxuICBzcGFuLmNoaWxkcmVuLmZvckVhY2goY3VycmVudCA9PiB7XHJcbiAgICBpZiAoaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUoY3VycmVudCkpIHtcclxuICAgICAgdGV4dCArPSBjdXJyZW50LnRleHQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oY3VycmVudCkpIHtcclxuICAgICAgdGV4dCArPSBzcGFuVG9QbGFpblRleHQoY3VycmVudCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHRleHQ7XHJcbn1cclxuY29uc3QgTElTVF9ORVNUX01PREVfSFRNTCA9IFwiaHRtbFwiO1xyXG5jb25zdCBMSVNUX05FU1RfTU9ERV9ESVJFQ1QgPSBcImRpcmVjdFwiO1xyXG5leHBvcnQgeyBMSVNUX05FU1RfTU9ERV9ESVJFQ1QsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGJ1aWxkTWFya3NUcmVlLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiwgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIG5lc3RMaXN0cywgc29ydE1hcmtzQnlPY2N1cmVuY2VzLCBzcGFuVG9QbGFpblRleHQsIHRvUGxhaW5UZXh0IH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcnRhYmxlLXRleHQtdG9vbGtpdC5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@portabletext/toolkit/dist/portable-text-toolkit.esm.js\n"));

/***/ }),

/***/ "./pages/[pageCategory].js":
/*!*********************************!*\
  !*** ./pages/[pageCategory].js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__N_SSG\": function() { return /* binding */ __N_SSG; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _sanity_image_url__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sanity/image-url */ \"./node_modules/@sanity/image-url/lib/browser/image-url.umd.js\");\n/* harmony import */ var _sanity_image_url__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_sanity_image_url__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../client */ \"./client.js\");\n/* harmony import */ var _components_global_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/global/Header */ \"./components/global/Header.js\");\n/* harmony import */ var _api_fetchMainPageContentByTitle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api/fetchMainPageContentByTitle */ \"./pages/api/fetchMainPageContentByTitle.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _functions_StringToKebabStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions/StringToKebabStyle */ \"./functions/StringToKebabStyle.js\");\n/* harmony import */ var _sanity_api_schemas_pageCategory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../sanity_api/schemas/pageCategory */ \"../sanity_api/schemas/pageCategory.js\");\n/* harmony import */ var _portabletext_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @portabletext/react */ \"./node_modules/@portabletext/react/dist/react-portable-text.esm.js\");\n\n\n\n\n\n\n\n\n\nfunction urlFor(source) {\n    return _sanity_image_url__WEBPACK_IMPORTED_MODULE_7___default()(_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).image(source);\n}\nconst Post = (param)=>{\n    let { pageCategory  } = param;\n    let imgSliderArr = [];\n    if (pageCategory.imageGallery) {\n        pageCategory.imageGallery[0].map((i)=>imgSliderArr.push(i._key));\n    }\n    const ptComponents = {\n        types: {\n            image: (param)=>{\n                let { value  } = param;\n                var ref;\n                if (!(value === null || value === void 0 ? void 0 : (ref = value.asset) === null || ref === void 0 ? void 0 : ref._ref)) {\n                    return null;\n                }\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        className: \"mx-auto my-12 w-1/2\",\n                        alt: value.alt || \" \",\n                        loading: \"lazy\",\n                        src: urlFor(value).width(1600).height(900).fit(\"max\").auto(\"format\")\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                        lineNumber: 31,\n                        columnNumber: 13\n                    }, undefined)\n                }, void 0, false);\n            }\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_global_Header__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                lineNumber: 49,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"flex justify-center z-0 top-64 h-auto m-auto bg-fixed bg-cover bg-parallax text-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"article\", {\n                    children: [\n                        pageCategory.headerImage && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            className: \"w-full h-64 rounded-lg object-cover my-8\",\n                            srcSet: urlFor(pageCategory.headerImage.asset._ref)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                            lineNumber: 54,\n                            columnNumber: 13\n                        }, undefined),\n                        pageCategory.ima,\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            children: \"Hi\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                            lineNumber: 60,\n                            columnNumber: 11\n                        }, undefined),\n                        pageCategory.body && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_portabletext_react__WEBPACK_IMPORTED_MODULE_8__.PortableText, {\n                            value: pageCategory.body,\n                            components: ptComponents\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                            lineNumber: 62,\n                            columnNumber: 34\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                    lineNumber: 52,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Lucas\\\\Documents\\\\GitHub\\\\Sanity_NextJS_BlogPage\\\\nextjs_frontend\\\\pages\\\\[pageCategory].js\",\n                lineNumber: 51,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_c = Post;\nvar __N_SSG = true;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Post);\nvar _c;\n$RefreshReg$(_c, \"Post\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9bcGFnZUNhdGVnb3J5XS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDZ0Q7QUFDakI7QUFDa0I7QUFDMkI7QUFDcEM7QUFDNkI7QUFDSjtBQUNkO0FBRW5ELFNBQVNRLE9BQU9DLE1BQU0sRUFBRTtJQUN0QixPQUFPVCx3REFBZUEsQ0FBQ0MsK0NBQU1BLEVBQUVTLEtBQUssQ0FBQ0Q7QUFDdkM7QUFFQSxNQUFNRSxPQUFPLFNBQXNCO1FBQXJCLEVBQUVMLGFBQVksRUFBRTtJQUU1QixJQUFJTSxlQUFlLEVBQUU7SUFFckIsSUFBSU4sYUFBYU8sWUFBWSxFQUFFO1FBQzdCUCxhQUFhTyxZQUFZLENBQUMsRUFBRSxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUgsYUFBYUksSUFBSSxDQUFDRCxFQUFFRSxJQUFJO0lBQ2xFLENBQUM7SUFFRCxNQUFNQyxlQUFlO1FBQ25CQyxPQUFPO1lBQ0xULE9BQU8sU0FBZTtvQkFBZCxFQUFFVSxNQUFLLEVBQUU7b0JBQ1ZBO2dCQUFMLElBQUksQ0FBQ0EsQ0FBQUEsa0JBQUFBLG1CQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxNQUFBQSxNQUFPQyxLQUFLLGNBQVpELGlCQUFBQSxLQUFBQSxJQUFBQSxJQUFjRSxJQUFGLEdBQVE7b0JBQ3ZCLE9BQU8sSUFBSTtnQkFDYixDQUFDO2dCQUNELHFCQUNFOzhCQUNFLDRFQUFDQzt3QkFDQ0MsV0FBVTt3QkFDVkMsS0FBS0wsTUFBTUssR0FBRyxJQUFJO3dCQUNsQkMsU0FBUTt3QkFDUkMsS0FBS25CLE9BQU9ZLE9BQ1RRLEtBQUssQ0FBQyxNQUNOQyxNQUFNLENBQUMsS0FDUEMsR0FBRyxDQUFDLE9BQ0pDLElBQUksQ0FBQzs7Ozs7OztZQUloQjtRQUNGO0lBQ0Y7SUFFQSxxQkFDRTs7MEJBQ0UsOERBQUM3QixpRUFBTUE7Ozs7OzBCQUVQLDhEQUFDOEI7Z0JBQVFSLFdBQVU7MEJBQ2pCLDRFQUFDUzs7d0JBQ0UzQixhQUFhNEIsV0FBVyxrQkFDdkIsOERBQUNYOzRCQUNDQyxXQUFVOzRCQUNWVyxRQUFRM0IsT0FBT0YsYUFBYTRCLFdBQVcsQ0FBQ2IsS0FBSyxDQUFDQyxJQUFJOzs7Ozs7d0JBR3JEaEIsYUFBYThCLEdBQUc7c0NBQ2pCLDhEQUFDQztzQ0FBRzs7Ozs7O3dCQUVGL0IsYUFBYWdDLElBQUksa0JBQUksOERBQUMvQiw2REFBWUE7NEJBQUNhLE9BQU9kLGFBQWFnQyxJQUFJOzRCQUFFQyxZQUFZckI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLckY7S0FwRE1QOztBQXNGTiwrREFBZUEsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9bcGFnZUNhdGVnb3J5XS5qcz8xZjZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBncm9xIGZyb20gXCJncm9xXCI7XHJcbmltcG9ydCBpbWFnZVVybEJ1aWxkZXIgZnJvbSBcIkBzYW5pdHkvaW1hZ2UtdXJsXCI7XHJcbmltcG9ydCBjbGllbnQgZnJvbSBcIi4uL2NsaWVudFwiO1xyXG5pbXBvcnQgSGVhZGVyIGZyb20gXCIuLi9jb21wb25lbnRzL2dsb2JhbC9IZWFkZXJcIjtcclxuaW1wb3J0IGZldGNoTWFpblBhZ2VDb250ZW50QnlUaXRsZSBmcm9tIFwiLi9hcGkvZmV0Y2hNYWluUGFnZUNvbnRlbnRCeVRpdGxlXCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgeyBTdHJpbmdUb0tlYmFiU3R5bGUgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL1N0cmluZ1RvS2ViYWJTdHlsZVwiO1xyXG5pbXBvcnQgcGFnZUNhdGVnb3J5IGZyb20gXCIuLi8uLi9zYW5pdHlfYXBpL3NjaGVtYXMvcGFnZUNhdGVnb3J5XCI7XHJcbmltcG9ydCB7IFBvcnRhYmxlVGV4dCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3JlYWN0XCI7XHJcblxyXG5mdW5jdGlvbiB1cmxGb3Ioc291cmNlKSB7XHJcbiAgcmV0dXJuIGltYWdlVXJsQnVpbGRlcihjbGllbnQpLmltYWdlKHNvdXJjZSk7XHJcbn1cclxuXHJcbmNvbnN0IFBvc3QgPSAoeyBwYWdlQ2F0ZWdvcnkgfSkgPT4ge1xyXG5cclxuICBsZXQgaW1nU2xpZGVyQXJyID0gW11cclxuXHJcbiAgaWYgKHBhZ2VDYXRlZ29yeS5pbWFnZUdhbGxlcnkpIHtcclxuICAgIHBhZ2VDYXRlZ29yeS5pbWFnZUdhbGxlcnlbMF0ubWFwKChpKSA9PiBpbWdTbGlkZXJBcnIucHVzaChpLl9rZXkpKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcHRDb21wb25lbnRzID0ge1xyXG4gICAgdHlwZXM6IHtcclxuICAgICAgaW1hZ2U6ICh7IHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoIXZhbHVlPy5hc3NldD8uX3JlZikge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICA8PlxyXG4gICAgICAgICAgICA8aW1nXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXgtYXV0byBteS0xMiB3LTEvMlwiXHJcbiAgICAgICAgICAgICAgYWx0PXt2YWx1ZS5hbHQgfHwgXCIgXCJ9XHJcbiAgICAgICAgICAgICAgbG9hZGluZz1cImxhenlcIlxyXG4gICAgICAgICAgICAgIHNyYz17dXJsRm9yKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLndpZHRoKDE2MDApXHJcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KDkwMClcclxuICAgICAgICAgICAgICAgIC5maXQoXCJtYXhcIilcclxuICAgICAgICAgICAgICAgIC5hdXRvKFwiZm9ybWF0XCIpfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC8+XHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDw+XHJcbiAgICAgIDxIZWFkZXIgLz5cclxuXHJcbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgei0wIHRvcC02NCBoLWF1dG8gbS1hdXRvIGJnLWZpeGVkIGJnLWNvdmVyIGJnLXBhcmFsbGF4IHRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgPGFydGljbGU+XHJcbiAgICAgICAgICB7cGFnZUNhdGVnb3J5LmhlYWRlckltYWdlICYmXHJcbiAgICAgICAgICAgIDxpbWdcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgaC02NCByb3VuZGVkLWxnIG9iamVjdC1jb3ZlciBteS04XCJcclxuICAgICAgICAgICAgICBzcmNTZXQ9e3VybEZvcihwYWdlQ2F0ZWdvcnkuaGVhZGVySW1hZ2UuYXNzZXQuX3JlZil9XHJcbiAgICAgICAgICAgIC8+fVxyXG5cclxuICAgICAgICAgIHtwYWdlQ2F0ZWdvcnkuaW1hfVxyXG4gICAgICAgICAgPGgxPkhpPC9oMT5cclxuXHJcbiAgICAgICAgICB7IHBhZ2VDYXRlZ29yeS5ib2R5ICYmIDxQb3J0YWJsZVRleHQgdmFsdWU9e3BhZ2VDYXRlZ29yeS5ib2R5fSBjb21wb25lbnRzPXtwdENvbXBvbmVudHN9IC8+fVxyXG4gICAgICAgIDwvYXJ0aWNsZT5cclxuICAgICAgPC9zZWN0aW9uPlxyXG4gICAgPC8+XHJcbiAgKTtcclxufTtcclxuXHJcbmNvbnN0IHF1ZXJ5ID0gZ3JvcWAqW190eXBlID09IFwicGFnZUNvbnRlbnRcIiAmJiAkc2x1ZyBpbiBwYWdlQ2F0ZWdvcnlbXS0+c2x1Zy5jdXJyZW50XVswXXtcclxuICB0aXRsZSxcclxuICBcInBhZ2VDYXRlZ29yeVwiOiBwYWdlQ2F0ZWdvcnlbXSAtPiB0aXRsZSxcclxuICBoZWFkZXJJbWFnZSxcclxuICBib2R5LFxyXG4gIFwiaW1hZ2VHYWxsZXJ5XCI6IGltYWdlR2FsbGVyeVtdLT5pbWFnZXNcclxufWBcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGF0aWNQYXRocygpIHtcclxuICBjb25zdCBwYXRocyA9IGF3YWl0IGNsaWVudC5mZXRjaChncm9xYCpbX3R5cGUgPT0gXCJwYWdlQ2F0ZWdvcnlcIl17XHJcbiAgICBzbHVnXHJcbiAgfVtdLnNsdWcuY3VycmVudGApO1xyXG4gIGNvbnNvbGUubG9nKGBQQVRIIExPR0dJTkc6ICR7cGF0aHN9YCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBhdGhzOiBwYXRocy5tYXAoKHBhZ2VDYXRlZ29yeSkgPT4gKHtcclxuICAgICAgcGFyYW1zOiB7IHBhZ2VDYXRlZ29yeTogcGFnZUNhdGVnb3J5IH0sXHJcbiAgICB9KSksXHJcbiAgICBmYWxsYmFjazogdHJ1ZSxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhdGljUHJvcHMoY29udGV4dCkge1xyXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRvIGRlZmF1bHQgdGhlIHNsdWcgc28gdGhhdCBpdCBkb2Vzbid0IHJldHVybiBcInVuZGVmaW5lZFwiXHJcbiAgY29uc3Qgc2x1ZyA9IGNvbnRleHQucGFyYW1zLnBhZ2VDYXRlZ29yeTtcclxuICBjb25zdCBwYWdlQ2F0ZWdvcnkgPSBhd2FpdCBjbGllbnQuZmV0Y2gocXVlcnksIHsgc2x1ZyB9KTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgIHBhZ2VDYXRlZ29yeSxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBQb3N0O1xyXG4iXSwibmFtZXMiOlsiaW1hZ2VVcmxCdWlsZGVyIiwiY2xpZW50IiwiSGVhZGVyIiwiZmV0Y2hNYWluUGFnZUNvbnRlbnRCeVRpdGxlIiwidXNlUm91dGVyIiwiU3RyaW5nVG9LZWJhYlN0eWxlIiwicGFnZUNhdGVnb3J5IiwiUG9ydGFibGVUZXh0IiwidXJsRm9yIiwic291cmNlIiwiaW1hZ2UiLCJQb3N0IiwiaW1nU2xpZGVyQXJyIiwiaW1hZ2VHYWxsZXJ5IiwibWFwIiwiaSIsInB1c2giLCJfa2V5IiwicHRDb21wb25lbnRzIiwidHlwZXMiLCJ2YWx1ZSIsImFzc2V0IiwiX3JlZiIsImltZyIsImNsYXNzTmFtZSIsImFsdCIsImxvYWRpbmciLCJzcmMiLCJ3aWR0aCIsImhlaWdodCIsImZpdCIsImF1dG8iLCJzZWN0aW9uIiwiYXJ0aWNsZSIsImhlYWRlckltYWdlIiwic3JjU2V0IiwiaW1hIiwiaDEiLCJib2R5IiwiY29tcG9uZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/[pageCategory].js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-jsx-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\nif (true) {\r\n  (function() {\r\n'use strict';\r\n\r\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\n\r\n// ATTENTION\r\n// When adding new symbols to this file,\r\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n// The Symbol used to tag the ReactElement-like types.\r\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\r\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\r\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\r\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\r\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\r\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\r\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\r\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\r\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\r\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\r\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\r\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\r\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\r\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\r\nfunction getIteratorFn(maybeIterable) {\r\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\r\n    return null;\r\n  }\r\n\r\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n\r\n  if (typeof maybeIterator === 'function') {\r\n    return maybeIterator;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\r\nvar enableCacheElement = false;\r\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\r\n\r\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\r\n// stuff. Intended to enable React core members to more easily debug scheduling\r\n// issues in DEV builds.\r\n\r\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\r\n\r\nvar REACT_MODULE_REFERENCE;\r\n\r\n{\r\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\r\n}\r\n\r\nfunction isValidElementType(type) {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true;\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n\r\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n    // types supported by any Flight configuration anywhere since\r\n    // we don't know which Flight build this will end up being used\r\n    // with.\r\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getWrappedName(outerType, innerType, wrapperName) {\r\n  var displayName = outerType.displayName;\r\n\r\n  if (displayName) {\r\n    return displayName;\r\n  }\r\n\r\n  var functionName = innerType.displayName || innerType.name || '';\r\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\r\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\r\n\r\n\r\nfunction getContextName(type) {\r\n  return type.displayName || 'Context';\r\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\r\n\r\n\r\nfunction getComponentNameFromType(type) {\r\n  if (type == null) {\r\n    // Host root, text node or just invalid type.\r\n    return null;\r\n  }\r\n\r\n  {\r\n    if (typeof type.tag === 'number') {\r\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    return type.displayName || type.name || null;\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return type;\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_FRAGMENT_TYPE:\r\n      return 'Fragment';\r\n\r\n    case REACT_PORTAL_TYPE:\r\n      return 'Portal';\r\n\r\n    case REACT_PROFILER_TYPE:\r\n      return 'Profiler';\r\n\r\n    case REACT_STRICT_MODE_TYPE:\r\n      return 'StrictMode';\r\n\r\n    case REACT_SUSPENSE_TYPE:\r\n      return 'Suspense';\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return 'SuspenseList';\r\n\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_CONTEXT_TYPE:\r\n        var context = type;\r\n        return getContextName(context) + '.Consumer';\r\n\r\n      case REACT_PROVIDER_TYPE:\r\n        var provider = type;\r\n        return getContextName(provider._context) + '.Provider';\r\n\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return getWrappedName(type, type.render, 'ForwardRef');\r\n\r\n      case REACT_MEMO_TYPE:\r\n        var outerName = type.displayName || null;\r\n\r\n        if (outerName !== null) {\r\n          return outerName;\r\n        }\r\n\r\n        return getComponentNameFromType(type.type) || 'Memo';\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            return getComponentNameFromType(init(payload));\r\n          } catch (x) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n      // eslint-disable-next-line no-fallthrough\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar assign = Object.assign;\r\n\r\n// Helpers to patch console.logs to avoid logging during side-effect free\r\n// replaying on render function. This currently only patches the object\r\n// lazily which won't cover if the log function was extracted eagerly.\r\n// We could also eagerly patch the method.\r\nvar disabledDepth = 0;\r\nvar prevLog;\r\nvar prevInfo;\r\nvar prevWarn;\r\nvar prevError;\r\nvar prevGroup;\r\nvar prevGroupCollapsed;\r\nvar prevGroupEnd;\r\n\r\nfunction disabledLog() {}\r\n\r\ndisabledLog.__reactDisabledLog = true;\r\nfunction disableLogs() {\r\n  {\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      prevLog = console.log;\r\n      prevInfo = console.info;\r\n      prevWarn = console.warn;\r\n      prevError = console.error;\r\n      prevGroup = console.group;\r\n      prevGroupCollapsed = console.groupCollapsed;\r\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\r\n\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        value: disabledLog,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        info: props,\r\n        log: props,\r\n        warn: props,\r\n        error: props,\r\n        group: props,\r\n        groupCollapsed: props,\r\n        groupEnd: props\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    disabledDepth++;\r\n  }\r\n}\r\nfunction reenableLogs() {\r\n  {\r\n    disabledDepth--;\r\n\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        log: assign({}, props, {\r\n          value: prevLog\r\n        }),\r\n        info: assign({}, props, {\r\n          value: prevInfo\r\n        }),\r\n        warn: assign({}, props, {\r\n          value: prevWarn\r\n        }),\r\n        error: assign({}, props, {\r\n          value: prevError\r\n        }),\r\n        group: assign({}, props, {\r\n          value: prevGroup\r\n        }),\r\n        groupCollapsed: assign({}, props, {\r\n          value: prevGroupCollapsed\r\n        }),\r\n        groupEnd: assign({}, props, {\r\n          value: prevGroupEnd\r\n        })\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    if (disabledDepth < 0) {\r\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\nvar prefix;\r\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\r\n  {\r\n    if (prefix === undefined) {\r\n      // Extract the VM specific prefix used by each line.\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\r\n        prefix = match && match[1] || '';\r\n      }\r\n    } // We use the prefix to ensure our stacks line up with native stack frames.\r\n\r\n\r\n    return '\\n' + prefix + name;\r\n  }\r\n}\r\nvar reentry = false;\r\nvar componentFrameCache;\r\n\r\n{\r\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n  componentFrameCache = new PossiblyWeakMap();\r\n}\r\n\r\nfunction describeNativeComponentFrame(fn, construct) {\r\n  // If something asked for a stack inside a fake render, it should get ignored.\r\n  if ( !fn || reentry) {\r\n    return '';\r\n  }\r\n\r\n  {\r\n    var frame = componentFrameCache.get(fn);\r\n\r\n    if (frame !== undefined) {\r\n      return frame;\r\n    }\r\n  }\r\n\r\n  var control;\r\n  reentry = true;\r\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\r\n\r\n  Error.prepareStackTrace = undefined;\r\n  var previousDispatcher;\r\n\r\n  {\r\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\r\n    // for warnings.\r\n\r\n    ReactCurrentDispatcher.current = null;\r\n    disableLogs();\r\n  }\r\n\r\n  try {\r\n    // This should throw.\r\n    if (construct) {\r\n      // Something should be setting the props in the constructor.\r\n      var Fake = function () {\r\n        throw Error();\r\n      }; // $FlowFixMe\r\n\r\n\r\n      Object.defineProperty(Fake.prototype, 'props', {\r\n        set: function () {\r\n          // We use a throwing setter instead of frozen or non-writable props\r\n          // because that won't throw in a non-strict mode function.\r\n          throw Error();\r\n        }\r\n      });\r\n\r\n      if (typeof Reflect === 'object' && Reflect.construct) {\r\n        // We construct a different control for this case to include any extra\r\n        // frames added by the construct call.\r\n        try {\r\n          Reflect.construct(Fake, []);\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        Reflect.construct(fn, [], Fake);\r\n      } else {\r\n        try {\r\n          Fake.call();\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        fn.call(Fake.prototype);\r\n      }\r\n    } else {\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        control = x;\r\n      }\r\n\r\n      fn();\r\n    }\r\n  } catch (sample) {\r\n    // This is inlined manually because closure doesn't do it for us.\r\n    if (sample && control && typeof sample.stack === 'string') {\r\n      // This extracts the first frame from the sample that isn't also in the control.\r\n      // Skipping one frame that we assume is the frame that calls the two.\r\n      var sampleLines = sample.stack.split('\\n');\r\n      var controlLines = control.stack.split('\\n');\r\n      var s = sampleLines.length - 1;\r\n      var c = controlLines.length - 1;\r\n\r\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n        // We expect at least one stack frame to be shared.\r\n        // Typically this will be the root most one. However, stack frames may be\r\n        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n        // earlier than the other. We assume that the sample is longer or the same\r\n        // and there for cut off earlier. So we should find the root most frame in\r\n        // the sample somewhere in the control.\r\n        c--;\r\n      }\r\n\r\n      for (; s >= 1 && c >= 0; s--, c--) {\r\n        // Next we find the first one that isn't the same which should be the\r\n        // frame that called our sample function and the control.\r\n        if (sampleLines[s] !== controlLines[c]) {\r\n          // In V8, the first line is describing the message but other VMs don't.\r\n          // If we're about to return the first line, and the control is also on the same\r\n          // line, that's a pretty good indicator that our sample threw at same line as\r\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n          // This can happen if you passed a class to function component, or non-function.\r\n          if (s !== 1 || c !== 1) {\r\n            do {\r\n              s--;\r\n              c--; // We may still have similar intermediate frames from the construct call.\r\n              // The next one that isn't the same should be our match though.\r\n\r\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\r\n                // but we have a user-provided \"displayName\"\r\n                // splice it in to make the stack more readable.\r\n\r\n\r\n                if (fn.displayName && _frame.includes('<anonymous>')) {\r\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\r\n                }\r\n\r\n                {\r\n                  if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, _frame);\r\n                  }\r\n                } // Return the line we found.\r\n\r\n\r\n                return _frame;\r\n              }\r\n            } while (s >= 1 && c >= 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } finally {\r\n    reentry = false;\r\n\r\n    {\r\n      ReactCurrentDispatcher.current = previousDispatcher;\r\n      reenableLogs();\r\n    }\r\n\r\n    Error.prepareStackTrace = previousPrepareStackTrace;\r\n  } // Fallback to just using the name if we couldn't make it throw.\r\n\r\n\r\n  var name = fn ? fn.displayName || fn.name : '';\r\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n\r\n  {\r\n    if (typeof fn === 'function') {\r\n      componentFrameCache.set(fn, syntheticFrame);\r\n    }\r\n  }\r\n\r\n  return syntheticFrame;\r\n}\r\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\r\n  {\r\n    return describeNativeComponentFrame(fn, false);\r\n  }\r\n}\r\n\r\nfunction shouldConstruct(Component) {\r\n  var prototype = Component.prototype;\r\n  return !!(prototype && prototype.isReactComponent);\r\n}\r\n\r\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n\r\n  if (type == null) {\r\n    return '';\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    {\r\n      return describeNativeComponentFrame(type, shouldConstruct(type));\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return describeBuiltInComponentFrame(type);\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_SUSPENSE_TYPE:\r\n      return describeBuiltInComponentFrame('Suspense');\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return describeBuiltInComponentFrame('SuspenseList');\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return describeFunctionComponentFrame(type.render);\r\n\r\n      case REACT_MEMO_TYPE:\r\n        // Memo may contain any component type so we recursively resolve it.\r\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            // Lazy may contain any component type so we recursively resolve it.\r\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n          } catch (x) {}\r\n        }\r\n    }\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nvar loggedTypeFailures = {};\r\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n  {\r\n    // $FlowFixMe This is okay but Flow doesn't know it.\r\n    var has = Function.call.bind(hasOwnProperty);\r\n\r\n    for (var typeSpecName in typeSpecs) {\r\n      if (has(typeSpecs, typeSpecName)) {\r\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\r\n        // fail the render phase where it didn't fail before. So we log it.\r\n        // After these have been cleaned up, we'll let them throw.\r\n\r\n        try {\r\n          // This is intentionally an invariant that gets caught. It's the same\r\n          // behavior as without this statement except with a better message.\r\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n            // eslint-disable-next-line react-internal/prod-error-codes\r\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\r\n            err.name = 'Invariant Violation';\r\n            throw err;\r\n          }\r\n\r\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\r\n        } catch (ex) {\r\n          error$1 = ex;\r\n        }\r\n\r\n        if (error$1 && !(error$1 instanceof Error)) {\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n\r\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n          // Only monitor this failure once because there tends to be a lot of the\r\n          // same error.\r\n          loggedTypeFailures[error$1.message] = true;\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('Failed %s type: %s', location, error$1.message);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\r\n\r\nfunction isArray(a) {\r\n  return isArrayImpl(a);\r\n}\r\n\r\n/*\r\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\r\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\r\n *\r\n * The functions in this module will throw an easier-to-understand,\r\n * easier-to-debug exception with a clear errors message message explaining the\r\n * problem. (Instead of a confusing exception thrown inside the implementation\r\n * of the `value` object).\r\n */\r\n// $FlowFixMe only called in DEV, so void return is not possible.\r\nfunction typeName(value) {\r\n  {\r\n    // toStringTag is needed for namespaced types like Temporal.Instant\r\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\r\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\r\n    return type;\r\n  }\r\n} // $FlowFixMe only called in DEV, so void return is not possible.\r\n\r\n\r\nfunction willCoercionThrow(value) {\r\n  {\r\n    try {\r\n      testStringCoercion(value);\r\n      return false;\r\n    } catch (e) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction testStringCoercion(value) {\r\n  // If you ended up here by following an exception call stack, here's what's\r\n  // happened: you supplied an object or symbol value to React (as a prop, key,\r\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\r\n  // coerce it to a string using `'' + value`, an exception was thrown.\r\n  //\r\n  // The most common types that will cause this exception are `Symbol` instances\r\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\r\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\r\n  // exception. (Library authors do this to prevent users from using built-in\r\n  // numeric operators like `+` or comparison operators like `>=` because custom\r\n  // methods are needed to perform accurate arithmetic or comparison.)\r\n  //\r\n  // To fix the problem, coerce this object or symbol value to a string before\r\n  // passing it to React. The most reliable way is usually `String(value)`.\r\n  //\r\n  // To find which value is throwing, check the browser or debugger console.\r\n  // Before this exception was thrown, there should be `console.error` output\r\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\r\n  // problem and how that type was used: key, atrribute, input value prop, etc.\r\n  // In most cases, this console output also shows the component and its\r\n  // ancestor components where the exception happened.\r\n  //\r\n  // eslint-disable-next-line react-internal/safe-string-coercion\r\n  return '' + value;\r\n}\r\nfunction checkKeyStringCoercion(value) {\r\n  {\r\n    if (willCoercionThrow(value)) {\r\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\r\n\r\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\nvar RESERVED_PROPS = {\r\n  key: true,\r\n  ref: true,\r\n  __self: true,\r\n  __source: true\r\n};\r\nvar specialPropKeyWarningShown;\r\nvar specialPropRefWarningShown;\r\nvar didWarnAboutStringRefs;\r\n\r\n{\r\n  didWarnAboutStringRefs = {};\r\n}\r\n\r\nfunction hasValidRef(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'ref')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.ref !== undefined;\r\n}\r\n\r\nfunction hasValidKey(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'key')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.key !== undefined;\r\n}\r\n\r\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\r\n  {\r\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\r\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\r\n\r\n      if (!didWarnAboutStringRefs[componentName]) {\r\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\r\n\r\n        didWarnAboutStringRefs[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction defineKeyPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingKey = function () {\r\n      if (!specialPropKeyWarningShown) {\r\n        specialPropKeyWarningShown = true;\r\n\r\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingKey.isReactWarning = true;\r\n    Object.defineProperty(props, 'key', {\r\n      get: warnAboutAccessingKey,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n\r\nfunction defineRefPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingRef = function () {\r\n      if (!specialPropRefWarningShown) {\r\n        specialPropRefWarningShown = true;\r\n\r\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingRef.isReactWarning = true;\r\n    Object.defineProperty(props, 'ref', {\r\n      get: warnAboutAccessingRef,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n/**\r\n * Factory method to create a new React element. This no longer adheres to\r\n * the class pattern, so do not use new to call it. Also, instanceof check\r\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n * if something is a React Element.\r\n *\r\n * @param {*} type\r\n * @param {*} props\r\n * @param {*} key\r\n * @param {string|object} ref\r\n * @param {*} owner\r\n * @param {*} self A *temporary* helper to detect places where `this` is\r\n * different from the `owner` when React.createElement is called, so that we\r\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n * functions, and as long as `this` and owner are the same, there will be no\r\n * change in behavior.\r\n * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n * indicating filename, line number, and/or other information.\r\n * @internal\r\n */\r\n\r\n\r\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\r\n  var element = {\r\n    // This tag allows us to uniquely identify this as a React Element\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n    // Built-in properties that belong on the element\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n    // Record the component responsible for creating this element.\r\n    _owner: owner\r\n  };\r\n\r\n  {\r\n    // The validation flag is currently mutative. We put it on\r\n    // an external backing store so that we can freeze the whole object.\r\n    // This can be replaced with a WeakMap once they are implemented in\r\n    // commonly used development environments.\r\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\r\n    // the validation flag non-enumerable (where possible, which should\r\n    // include every environment we run tests in), so the test framework\r\n    // ignores it.\r\n\r\n    Object.defineProperty(element._store, 'validated', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: true,\r\n      value: false\r\n    }); // self and source are DEV only properties.\r\n\r\n    Object.defineProperty(element, '_self', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: self\r\n    }); // Two elements created in two different places should be considered\r\n    // equal for testing purposes and therefore we hide it from enumeration.\r\n\r\n    Object.defineProperty(element, '_source', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: source\r\n    });\r\n\r\n    if (Object.freeze) {\r\n      Object.freeze(element.props);\r\n      Object.freeze(element);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n/**\r\n * https://github.com/reactjs/rfcs/pull/107\r\n * @param {*} type\r\n * @param {object} props\r\n * @param {string} key\r\n */\r\n\r\nfunction jsxDEV(type, config, maybeKey, source, self) {\r\n  {\r\n    var propName; // Reserved names are extracted\r\n\r\n    var props = {};\r\n    var key = null;\r\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\r\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\r\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\r\n    // but as an intermediary step, we will use jsxDEV for everything except\r\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\r\n    // key is explicitly declared to be undefined or not.\r\n\r\n    if (maybeKey !== undefined) {\r\n      {\r\n        checkKeyStringCoercion(maybeKey);\r\n      }\r\n\r\n      key = '' + maybeKey;\r\n    }\r\n\r\n    if (hasValidKey(config)) {\r\n      {\r\n        checkKeyStringCoercion(config.key);\r\n      }\r\n\r\n      key = '' + config.key;\r\n    }\r\n\r\n    if (hasValidRef(config)) {\r\n      ref = config.ref;\r\n      warnIfStringRefCannotBeAutoConverted(config, self);\r\n    } // Remaining properties are added to a new props object\r\n\r\n\r\n    for (propName in config) {\r\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n        props[propName] = config[propName];\r\n      }\r\n    } // Resolve default props\r\n\r\n\r\n    if (type && type.defaultProps) {\r\n      var defaultProps = type.defaultProps;\r\n\r\n      for (propName in defaultProps) {\r\n        if (props[propName] === undefined) {\r\n          props[propName] = defaultProps[propName];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (key || ref) {\r\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\r\n\r\n      if (key) {\r\n        defineKeyPropWarningGetter(props, displayName);\r\n      }\r\n\r\n      if (ref) {\r\n        defineRefPropWarningGetter(props, displayName);\r\n      }\r\n    }\r\n\r\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\r\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement$1(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nvar propTypesMisspellWarningShown;\r\n\r\n{\r\n  propTypesMisspellWarningShown = false;\r\n}\r\n/**\r\n * Verifies the object is a ReactElement.\r\n * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n * @param {?object} object\r\n * @return {boolean} True if `object` is a ReactElement.\r\n * @final\r\n */\r\n\r\n\r\nfunction isValidElement(object) {\r\n  {\r\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n  }\r\n}\r\n\r\nfunction getDeclarationErrorAddendum() {\r\n  {\r\n    if (ReactCurrentOwner$1.current) {\r\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\r\n\r\n      if (name) {\r\n        return '\\n\\nCheck the render method of `' + name + '`.';\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n\r\nfunction getSourceInfoErrorAddendum(source) {\r\n  {\r\n    if (source !== undefined) {\r\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\r\n      var lineNumber = source.lineNumber;\r\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n/**\r\n * Warn if there's no key explicitly set on dynamic arrays of children or\r\n * object keys are not valid. This allows us to keep track of children between\r\n * updates.\r\n */\r\n\r\n\r\nvar ownerHasKeyUseWarning = {};\r\n\r\nfunction getCurrentComponentErrorInfo(parentType) {\r\n  {\r\n    var info = getDeclarationErrorAddendum();\r\n\r\n    if (!info) {\r\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\r\n\r\n      if (parentName) {\r\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n/**\r\n * Warn if the element doesn't have an explicit key assigned to it.\r\n * This element is in an array. The array could grow and shrink or be\r\n * reordered. All children that haven't already been validated are required to\r\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n * will only be shown once.\r\n *\r\n * @internal\r\n * @param {ReactElement} element Element that requires a key.\r\n * @param {*} parentType element's parent's type.\r\n */\r\n\r\n\r\nfunction validateExplicitKey(element, parentType) {\r\n  {\r\n    if (!element._store || element._store.validated || element.key != null) {\r\n      return;\r\n    }\r\n\r\n    element._store.validated = true;\r\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n\r\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n      return;\r\n    }\r\n\r\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\r\n    // property, it may be the creator of the child that's responsible for\r\n    // assigning it a key.\r\n\r\n    var childOwner = '';\r\n\r\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\r\n      // Give the component that originally created this child.\r\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\r\n    }\r\n\r\n    setCurrentlyValidatingElement$1(element);\r\n\r\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\r\n\r\n    setCurrentlyValidatingElement$1(null);\r\n  }\r\n}\r\n/**\r\n * Ensure that every element either is passed in a static location, in an\r\n * array with an explicit keys property defined, or in an object literal\r\n * with valid key property.\r\n *\r\n * @internal\r\n * @param {ReactNode} node Statically passed child of any type.\r\n * @param {*} parentType node's parent's type.\r\n */\r\n\r\n\r\nfunction validateChildKeys(node, parentType) {\r\n  {\r\n    if (typeof node !== 'object') {\r\n      return;\r\n    }\r\n\r\n    if (isArray(node)) {\r\n      for (var i = 0; i < node.length; i++) {\r\n        var child = node[i];\r\n\r\n        if (isValidElement(child)) {\r\n          validateExplicitKey(child, parentType);\r\n        }\r\n      }\r\n    } else if (isValidElement(node)) {\r\n      // This element was passed in a valid location.\r\n      if (node._store) {\r\n        node._store.validated = true;\r\n      }\r\n    } else if (node) {\r\n      var iteratorFn = getIteratorFn(node);\r\n\r\n      if (typeof iteratorFn === 'function') {\r\n        // Entry iterators used to provide implicit keys,\r\n        // but now we print a separate warning for them later.\r\n        if (iteratorFn !== node.entries) {\r\n          var iterator = iteratorFn.call(node);\r\n          var step;\r\n\r\n          while (!(step = iterator.next()).done) {\r\n            if (isValidElement(step.value)) {\r\n              validateExplicitKey(step.value, parentType);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given an element, validate that its props follow the propTypes definition,\r\n * provided by the type.\r\n *\r\n * @param {ReactElement} element\r\n */\r\n\r\n\r\nfunction validatePropTypes(element) {\r\n  {\r\n    var type = element.type;\r\n\r\n    if (type === null || type === undefined || typeof type === 'string') {\r\n      return;\r\n    }\r\n\r\n    var propTypes;\r\n\r\n    if (typeof type === 'function') {\r\n      propTypes = type.propTypes;\r\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\r\n    // Inner props are checked in the reconciler.\r\n    type.$$typeof === REACT_MEMO_TYPE)) {\r\n      propTypes = type.propTypes;\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    if (propTypes) {\r\n      // Intentionally inside to avoid triggering lazy initializers:\r\n      var name = getComponentNameFromType(type);\r\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\r\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\r\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\r\n\r\n      var _name = getComponentNameFromType(type);\r\n\r\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\r\n    }\r\n\r\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\r\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given a fragment, validate that it can only be provided with fragment props\r\n * @param {ReactElement} fragment\r\n */\r\n\r\n\r\nfunction validateFragmentProps(fragment) {\r\n  {\r\n    var keys = Object.keys(fragment.props);\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n\r\n      if (key !== 'children' && key !== 'key') {\r\n        setCurrentlyValidatingElement$1(fragment);\r\n\r\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\r\n\r\n        setCurrentlyValidatingElement$1(null);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (fragment.ref !== null) {\r\n      setCurrentlyValidatingElement$1(fragment);\r\n\r\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\r\n\r\n      setCurrentlyValidatingElement$1(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\r\n  {\r\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\r\n    // succeed and there will likely be errors in render.\r\n\r\n    if (!validType) {\r\n      var info = '';\r\n\r\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\r\n      }\r\n\r\n      var sourceInfo = getSourceInfoErrorAddendum(source);\r\n\r\n      if (sourceInfo) {\r\n        info += sourceInfo;\r\n      } else {\r\n        info += getDeclarationErrorAddendum();\r\n      }\r\n\r\n      var typeString;\r\n\r\n      if (type === null) {\r\n        typeString = 'null';\r\n      } else if (isArray(type)) {\r\n        typeString = 'array';\r\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\r\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\r\n        info = ' Did you accidentally export a JSX literal instead of a component?';\r\n      } else {\r\n        typeString = typeof type;\r\n      }\r\n\r\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\r\n    }\r\n\r\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\r\n    // TODO: Drop this when these are no longer allowed as the type argument.\r\n\r\n    if (element == null) {\r\n      return element;\r\n    } // Skip key warning if the type isn't valid since our key validation logic\r\n    // doesn't expect a non-string/function type and can throw confusing errors.\r\n    // We don't want exception behavior to differ between dev and prod.\r\n    // (Rendering will throw with a helpful message and as soon as the type is\r\n    // fixed, the key warnings will appear.)\r\n\r\n\r\n    if (validType) {\r\n      var children = props.children;\r\n\r\n      if (children !== undefined) {\r\n        if (isStaticChildren) {\r\n          if (isArray(children)) {\r\n            for (var i = 0; i < children.length; i++) {\r\n              validateChildKeys(children[i], type);\r\n            }\r\n\r\n            if (Object.freeze) {\r\n              Object.freeze(children);\r\n            }\r\n          } else {\r\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\r\n          }\r\n        } else {\r\n          validateChildKeys(children, type);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (type === REACT_FRAGMENT_TYPE) {\r\n      validateFragmentProps(element);\r\n    } else {\r\n      validatePropTypes(element);\r\n    }\r\n\r\n    return element;\r\n  }\r\n} // These two functions exist to still get child warnings in dev\r\n// even with the prod transform. This means that jsxDEV is purely\r\n// opt-in behavior for better messages but that we won't stop\r\n// giving you warnings if you use production apis.\r\n\r\nfunction jsxWithValidationStatic(type, props, key) {\r\n  {\r\n    return jsxWithValidation(type, props, key, true);\r\n  }\r\n}\r\nfunction jsxWithValidationDynamic(type, props, key) {\r\n  {\r\n    return jsxWithValidation(type, props, key, false);\r\n  }\r\n}\r\n\r\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\r\n// for now we can ship identical prod functions\r\n\r\nvar jsxs =  jsxWithValidationStatic ;\r\n\r\nexports.Fragment = REACT_FRAGMENT_TYPE;\r\nexports.jsx = jsx;\r\nexports.jsxs = jsxs;\r\n  })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLDRDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsWUFBWTtBQUNaLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzPzJmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlIFJlYWN0XHJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAoZnVuY3Rpb24oKSB7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG4vLyBBVFRFTlRJT05cclxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxyXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXHJcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xyXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcclxudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xyXG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XHJcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcclxudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xyXG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xyXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcclxudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcclxudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XHJcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XHJcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcclxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XHJcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcclxuXHJcbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xyXG4gIHtcclxuICAgIHtcclxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcclxuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XHJcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXHJcbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXHJcbiAge1xyXG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XHJcblxyXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xyXG4gICAgICBmb3JtYXQgKz0gJyVzJztcclxuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xyXG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cclxuXHJcblxyXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcclxuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxyXG5cclxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxyXG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xyXG5cclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cclxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xyXG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcclxuXHJcbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXHJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcclxuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXHJcblxyXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxyXG5cclxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XHJcblxyXG57XHJcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXHJcblxyXG5cclxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcclxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxyXG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxyXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXHJcbiAgICAvLyB3aXRoLlxyXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xyXG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcclxuXHJcbiAgaWYgKGRpc3BsYXlOYW1lKSB7XHJcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XHJcbiAgfVxyXG5cclxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xyXG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XHJcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xyXG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0JztcclxufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZSA9PSBudWxsKSB7XHJcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxyXG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XHJcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xyXG5cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcclxuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XHJcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XHJcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcblxyXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXHJcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XHJcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cclxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXHJcbnZhciBkaXNhYmxlZERlcHRoID0gMDtcclxudmFyIHByZXZMb2c7XHJcbnZhciBwcmV2SW5mbztcclxudmFyIHByZXZXYXJuO1xyXG52YXIgcHJldkVycm9yO1xyXG52YXIgcHJldkdyb3VwO1xyXG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xyXG52YXIgcHJldkdyb3VwRW5kO1xyXG5cclxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxyXG5cclxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcclxuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XHJcbiAge1xyXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcclxuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XHJcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xyXG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xyXG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xyXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xyXG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XHJcblxyXG4gICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XHJcbiAgICAgICAgaW5mbzogcHJvcHMsXHJcbiAgICAgICAgbG9nOiBwcm9wcyxcclxuICAgICAgICB3YXJuOiBwcm9wcyxcclxuICAgICAgICBlcnJvcjogcHJvcHMsXHJcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxyXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcclxuICAgICAgICBncm91cEVuZDogcHJvcHNcclxuICAgICAgfSk7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICB9XHJcblxyXG4gICAgZGlzYWJsZWREZXB0aCsrO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XHJcbiAge1xyXG4gICAgZGlzYWJsZWREZXB0aC0tO1xyXG5cclxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcclxuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcclxuICAgICAgICB9KSxcclxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcclxuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xyXG52YXIgcHJlZml4O1xyXG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcclxuICB7XHJcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xyXG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxyXG5cclxuXHJcbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xyXG4gIH1cclxufVxyXG52YXIgcmVlbnRyeSA9IGZhbHNlO1xyXG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcclxuXHJcbntcclxuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xyXG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xyXG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxyXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIHtcclxuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcclxuXHJcbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgY29udHJvbDtcclxuICByZWVudHJ5ID0gdHJ1ZTtcclxuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cclxuXHJcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XHJcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcclxuXHJcbiAge1xyXG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuICAgIC8vIGZvciB3YXJuaW5ncy5cclxuXHJcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgZGlzYWJsZUxvZ3MoKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cclxuICAgIGlmIChjb25zdHJ1Y3QpIHtcclxuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgIH07IC8vICRGbG93Rml4TWVcclxuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cclxuICAgICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcclxuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXHJcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgRmFrZS5jYWxsKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoc2FtcGxlKSB7XHJcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxyXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXHJcbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxyXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xyXG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XHJcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcclxuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cclxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXHJcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcclxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxyXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXHJcbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgYy0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcclxuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcclxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cclxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cclxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcclxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXHJcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXHJcbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxyXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgcy0tO1xyXG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXHJcbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcclxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XHJcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgcmVlbnRyeSA9IGZhbHNlO1xyXG5cclxuICAgIHtcclxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xyXG4gICAgICByZWVuYWJsZUxvZ3MoKTtcclxuICAgIH1cclxuXHJcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XHJcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXHJcblxyXG5cclxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xyXG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xyXG5cclxuICB7XHJcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XHJcbn1cclxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcclxuICB7XHJcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xyXG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xyXG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XHJcblxyXG4gIGlmICh0eXBlID09IG51bGwpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAge1xyXG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XHJcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxyXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xyXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xyXG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xyXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XHJcblxyXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XHJcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxyXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XHJcblxyXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xyXG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xyXG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xyXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cclxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcclxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcclxuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XHJcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgIGVycm9yJDEgPSBleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XHJcblxyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcclxuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxyXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cclxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xyXG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcclxufVxyXG5cclxuLypcclxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXHJcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcclxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxyXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cclxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cclxuICovXHJcbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXHJcbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XHJcbiAge1xyXG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxyXG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XHJcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcclxuICAgIHJldHVybiB0eXBlO1xyXG4gIH1cclxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxyXG5cclxuXHJcbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XHJcbiAge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xyXG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xyXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXHJcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xyXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxyXG4gIC8vXHJcbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXHJcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcclxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcclxuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cclxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cclxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxyXG4gIC8vXHJcbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxyXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cclxuICAvL1xyXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXHJcbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XHJcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxyXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXHJcbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xyXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cclxuICAvL1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxyXG4gIHJldHVybiAnJyArIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcclxuICB7XHJcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XHJcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XHJcblxyXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xyXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XHJcbiAga2V5OiB0cnVlLFxyXG4gIHJlZjogdHJ1ZSxcclxuICBfX3NlbGY6IHRydWUsXHJcbiAgX19zb3VyY2U6IHRydWVcclxufTtcclxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xyXG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XHJcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xyXG5cclxue1xyXG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XHJcbiAge1xyXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcclxuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xyXG5cclxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xyXG4gIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcclxuXHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcclxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcclxuXHJcbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xyXG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcclxuXHJcbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHtcclxuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcclxuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xyXG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHtcclxuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcclxuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xyXG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXHJcbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXHJcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xyXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHR5cGVcclxuICogQHBhcmFtIHsqfSBwcm9wc1xyXG4gKiBAcGFyYW0geyp9IGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxyXG4gKiBAcGFyYW0geyp9IG93bmVyXHJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xyXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXHJcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XHJcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cclxuICogY2hhbmdlIGluIGJlaGF2aW9yLlxyXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcclxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5cclxuXHJcbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSB7XHJcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcclxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXHJcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAga2V5OiBrZXksXHJcbiAgICByZWY6IHJlZixcclxuICAgIHByb3BzOiBwcm9wcyxcclxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXHJcbiAgICBfb3duZXI6IG93bmVyXHJcbiAgfTtcclxuXHJcbiAge1xyXG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxyXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cclxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cclxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxyXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcclxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcclxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXHJcbiAgICAvLyBpZ25vcmVzIGl0LlxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICB2YWx1ZTogZmFsc2VcclxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgdmFsdWU6IHNlbGZcclxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxyXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICB2YWx1ZTogc291cmNlXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcbi8qKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XHJcbiAqIEBwYXJhbSB7Kn0gdHlwZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcclxuICB7XHJcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcclxuXHJcbiAgICB2YXIgcHJvcHMgPSB7fTtcclxuICAgIHZhciBrZXkgPSBudWxsO1xyXG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxyXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XHJcbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxyXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XHJcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxyXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cclxuXHJcbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB7XHJcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcclxuICAgICAge1xyXG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xyXG4gICAgICByZWYgPSBjb25maWcucmVmO1xyXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcclxuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxyXG5cclxuXHJcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xyXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcclxuXHJcblxyXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcclxuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xyXG5cclxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcclxuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtleSB8fCByZWYpIHtcclxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xyXG5cclxuICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xyXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xyXG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XHJcblxyXG57XHJcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcclxufVxyXG4vKipcclxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cclxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxyXG4gKiBAZmluYWxcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XHJcbiAge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcclxuICB7XHJcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XHJcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcclxuXHJcbiAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XHJcbiAge1xyXG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XHJcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XHJcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxyXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cclxuICogdXBkYXRlcy5cclxuICovXHJcblxyXG5cclxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XHJcbiAge1xyXG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcclxuXHJcbiAgICBpZiAoIWluZm8pIHtcclxuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XHJcblxyXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xyXG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbmZvO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxyXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcclxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXHJcbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xyXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xyXG5cclxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXHJcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXHJcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXHJcblxyXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcclxuXHJcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XHJcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxyXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xyXG5cclxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xyXG5cclxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXHJcbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxyXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xyXG5cclxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cclxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XHJcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChub2RlKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcclxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cclxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XHJcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XHJcbiAgICAgICAgICB2YXIgc3RlcDtcclxuXHJcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXHJcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3BUeXBlcztcclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXHJcbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cclxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcclxuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb3BUeXBlcykge1xyXG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcclxuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xyXG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XHJcblxyXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XHJcblxyXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xyXG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcclxuICB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcblxyXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcclxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcclxuXHJcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xyXG5cclxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xyXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcclxuXHJcbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xyXG5cclxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xyXG4gIHtcclxuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXHJcbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxyXG5cclxuICAgIGlmICghdmFsaWRUeXBlKSB7XHJcbiAgICAgIHZhciBpbmZvID0gJyc7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcclxuXHJcbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0eXBlU3RyaW5nO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcclxuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xyXG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cclxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cclxuXHJcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xyXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxyXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxyXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcclxuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcclxuXHJcblxyXG4gICAgaWYgKHZhbGlkVHlwZSkge1xyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcclxuXHJcbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XHJcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcclxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcclxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxyXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxyXG5cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xyXG4gIHtcclxuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcclxuICB7XHJcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cclxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcclxuXHJcbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcclxuXHJcbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG5leHBvcnRzLmpzeCA9IGpzeDtcclxuZXhwb3J0cy5qc3hzID0ganN4cztcclxuICB9KSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSwrSUFBa0U7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzM0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ })

});